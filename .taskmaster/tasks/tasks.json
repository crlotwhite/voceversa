{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "CMake 프로젝트 구조 및 개발 환경 설정",
        "description": "프로젝트의 기본적인 빌드 시스템과 개발 환경을 구축하고, 크로스플랫폼 지원을 위한 CMake 설정 구성",
        "details": "CMakeLists.txt 작성하여 C++ 17 이상 버전 지원, 플랫폼별 컴파일러 설정, 외부 라이브러리 연동 준비, src/, include/, tests/, examples/ 디렉토리 구조 생성. Windows (MSVC), macOS (Clang), Linux (GCC) 빌드 지원. 의존성 관리를 위한 vcpkg 또는 conan 설정 고려.",
        "testStrategy": "각 플랫폼에서 빌드 성공 확인, 기본 헬로월드 프로그램 컴파일 및 실행 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 디렉토리 구조 생성 및 C++ 프로젝트 설정",
            "description": "표준적인 C++ 프로젝트를 위한 디렉토리 구조를 생성하고 코드 구성의 기반을 마련",
            "dependencies": [],
            "details": "src/, include/, tests/, examples/, external/, build/, docs/ 디렉토리 생성. 각 디렉토리에 필요한 .gitkeep 파일 또는 기본 README.md 파일 생성. 프로젝트 루트에 .gitignore 파일 생성하여 빌드 아티팩트, 임시 파일 등 제외 설정. LICENSE 파일 및 기본 README.md 작성.",
            "status": "done",
            "testStrategy": "디렉토리 구조가 올바르게 생성되었는지 확인, git 저장소에 올바르게 추가되는지 검증"
          },
          {
            "id": 2,
            "title": "CMakeLists.txt 작성 및 C++17 빌드 시스템 구성",
            "description": "크로스플랫폼 빌드를 지원하는 CMake 설정 파일 작성 및 C++17 표준 지원",
            "dependencies": [
              "1.1"
            ],
            "details": "루트 CMakeLists.txt에서 cmake_minimum_required 3.16 이상 설정, PROJECT() 명령으로 프로젝트 정의, C++17 표준 설정 (set(CMAKE_CXX_STANDARD 17), set(CMAKE_CXX_STANDARD_REQUIRED ON)). 컴파일러별 최적화 플래그 및 경고 설정 (-Wall, -Wextra for GCC/Clang, /W3 for MSVC). 플랫폼별 조건부 컴파일 설정 추가.",
            "status": "done",
            "testStrategy": "Windows, macOS, Linux에서 cmake 명령 실행 성공 확인, C++17 기능이 정상 컴파일되는지 테스트"
          },
          {
            "id": 3,
            "title": "외부 라이브러리 의존성 관리 시스템 구축",
            "description": "vcpkg 또는 conan을 활용한 외부 라이브러리 의존성 관리 시스템 구성",
            "dependencies": [
              "1.2"
            ],
            "details": "vcpkg.json 또는 conanfile.txt 작성하여 필요한 라이브러리 목록 정의. CMake에서 find_package() 명령을 통한 라이브러리 검색 및 링크 설정. 향후 필요할 ONNX Runtime, 오디오 처리 라이브러리(libsndfile) 등의 의존성 설정 준비. 플랫폼별 라이브러리 경로 설정 및 정적/동적 링크 옵션 구성.",
            "status": "done",
            "testStrategy": "의존성 관리 도구가 정상 작동하는지 확인, 기본 라이브러리 하나 이상 성공적으로 링크되는지 테스트"
          },
          {
            "id": 4,
            "title": "플랫폼별 컴파일러 설정 및 빌드 스크립트 작성",
            "description": "Windows(MSVC), macOS(Clang), Linux(GCC) 각 플랫폼에 최적화된 빌드 스크립트 및 설정 구성",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "각 플랫폼별 build.sh/build.bat 스크립트 작성. CMakePresets.json을 활용한 플랫폼별 빌드 구성 사전 정의. 컴파일러별 최적화 옵션 (-O2, -O3) 및 디버그 정보 설정. 정적 분석 도구 (clang-tidy, cppcheck) 통합 설정. Release/Debug 빌드 타입별 설정 차별화.",
            "status": "done",
            "testStrategy": "각 플랫폼에서 빌드 스크립트 실행 성공 확인, Release/Debug 모드 모두 정상 빌드되는지 검증"
          },
          {
            "id": 5,
            "title": "기본 Hello World 프로그램 작성 및 빌드 검증",
            "description": "기본적인 C++ Hello World 프로그램을 작성하여 전체 빌드 시스템이 올바르게 동작하는지 검증",
            "dependencies": [
              "1.2",
              "1.4"
            ],
            "details": "src/main.cpp에 간단한 Hello World 프로그램 작성. CMakeLists.txt에 실행 파일 타겟 추가 (add_executable). include/ 디렉토리의 헤더 파일 포함 설정. 컴파일, 링크, 실행이 모든 플랫폼에서 성공하는지 확인하는 기본 테스트 케이스 작성. 향후 라이브러리 구조를 고려한 기본 헤더 파일 구조 설계.",
            "status": "done",
            "testStrategy": "모든 지원 플랫폼에서 Hello World 프로그램 컴파일 및 실행 성공 확인, 출력 결과 정확성 검증"
          }
        ]
      },
      {
        "id": 2,
        "title": "코어 인터페이스 및 데이터 구조 설계",
        "description": "ISynthesisNode, DataPacket, ComputationGraph 등 핵심 추상화 인터페이스와 데이터 구조를 설계하고 구현",
        "details": "ISynthesisNode 추상 클래스 (process(), initialize(), getInputs(), getOutputs() 메서드), DataPacket 클래스 (오디오 데이터, 메타데이터, 타임스탬프 포함), ComputationGraph 클래스 (노드 연결, 실행 순서 관리, 병렬 처리 지원), IPlatformIO 인터페이스 (파일 I/O, 메모리 관리 추상화). 스마트 포인터 활용한 메모리 안전성 확보.",
        "testStrategy": "인터페이스 단위 테스트, 모의 노드를 통한 그래프 연결 테스트, 메모리 누수 검사",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "ISynthesisNode 추상 클래스 및 기본 노드 인터페이스 설계",
            "description": "모든 음성 합성 노드의 기반이 되는 ISynthesisNode 추상 클래스와 핵심 메서드들을 설계 및 구현",
            "dependencies": [],
            "details": "include/core/ISynthesisNode.h 파일에 ISynthesisNode 추상 클래스 정의. process(const DataPacket& input) -> DataPacket, initialize() -> bool, getInputs() -> vector<string>, getOutputs() -> vector<string> 순수 가상 메서드 선언. 노드 ID, 이름, 상태 관리를 위한 멤버 변수 및 getter/setter 메서드 포함. 스마트 포인터(shared_ptr, unique_ptr) 사용을 위한 메모리 관리 정책 정의.",
            "status": "done",
            "testStrategy": "추상 클래스의 인터페이스 계약 검증을 위한 모킹 노드 구현 및 단위 테스트"
          },
          {
            "id": 2,
            "title": "DataPacket 클래스 및 오디오 데이터 구조 구현",
            "description": "오디오 데이터, 메타데이터, 타임스탬프를 포함한 범용 데이터 패킷 클래스 구현",
            "dependencies": [],
            "details": "include/core/DataPacket.h에 DataPacket 클래스 정의. 오디오 데이터는 vector<float> 또는 vector<double>로 저장, 샘플레이트, 채널 수, 비트뎁스 메타데이터 포함. 타임스탬프는 std::chrono를 사용한 고정밀 시간 정보. 데이터 직렬화/역직렬화 메서드, 깊은 복사/이동 생성자, RAII 원칙 준수한 메모리 관리. 템플릿 기반으로 다양한 데이터 타입 지원.",
            "status": "done",
            "testStrategy": "다양한 오디오 포맷 데이터 저장/복원 테스트, 메모리 사용량 및 복사 성능 벤치마크"
          },
          {
            "id": 3,
            "title": "ComputationGraph 클래스 기본 구조 및 노드 관리 시스템",
            "description": "노드 연결, 의존성 관리, 기본적인 실행 순서 결정 기능을 포함한 ComputationGraph 클래스 구현",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "include/core/ComputationGraph.h에 ComputationGraph 클래스 정의. addNode(), removeNode(), connectNodes() 메서드로 그래프 구성. 내부적으로 adjacency list 또는 adjacency matrix로 노드 연결 관계 저장. 위상 정렬 알고리즘 구현으로 실행 순서 결정. 순환 참조 검출 및 오류 처리. 노드 간 데이터 흐름 검증 메커니즘.",
            "status": "done",
            "testStrategy": "다양한 그래프 구조에서 위상 정렬 정확성 검증, 순환 참조 감지 테스트, 노드 추가/제거 시 일관성 유지 확인"
          },
          {
            "id": 4,
            "title": "ComputationGraph 병렬 처리 및 실행 엔진 구현",
            "description": "멀티스레드 기반 병렬 노드 실행, 스케줄링, 동기화 메커니즘 구현",
            "dependencies": [
              "2.3"
            ],
            "details": "std::thread, std::async를 사용한 병렬 실행 엔진 구현. execute() 메서드에서 의존성 그래프 기반 스케줄링, 독립적 노드들의 병렬 실행. std::mutex, std::condition_variable로 노드 간 동기화. 스레드풀 패턴 적용으로 스레드 생성/소멸 오버헤드 최소화. 실행 진행률 모니터링 및 중단 메커니즘 제공.",
            "status": "done",
            "testStrategy": "병렬 실행 정확성 검증, 스레드 안전성 테스트, 다양한 그래프 크기에서 성능 벤치마크"
          },
          {
            "id": 5,
            "title": "IPlatformIO 인터페이스 및 플랫폼 추상화 레이어 구현",
            "description": "파일 I/O, 메모리 관리를 추상화한 플랫폼 독립적 인터페이스 설계 및 기본 구현체 제공",
            "dependencies": [],
            "details": "include/core/IPlatformIO.h에 IPlatformIO 인터페이스 정의. readFile(), writeFile(), allocateMemory(), deallocateMemory() 등 플랫폼별 차이를 추상화한 메서드 선언. src/platform/에 Windows, macOS, Linux별 구현체 클래스 작성. 파일 경로 처리, 메모리 할당 정책, 예외 처리 표준화. Factory 패턴으로 플랫폼 자동 감지 및 적절한 구현체 반환.",
            "status": "done",
            "testStrategy": "각 플랫폼에서 파일 I/O 동작 일관성 검증, 메모리 할당/해제 안전성 테스트, 플랫폼별 특수 케이스 처리 확인"
          }
        ]
      },
      {
        "id": 3,
        "title": "WORLD 알고리즘 분석 및 합성 노드 구현",
        "description": "WORLD 보코더 알고리즘을 분석하고 WorldAnalysisNode와 WorldSynthesisNode를 구현하여 F0 추출, 스펙트럼 분석, 파형 합성 기능 제공",
        "details": "WORLD 논문 및 공개 알고리즘 분석하여 F0 추출 (DIO, Harvest), 스펙트럼 분석 (CheapTrick), 비주기성 지표 (D4C) 알고리즘 구현. WorldAnalysisNode는 WAV 입력을 받아 F0, 스펙트로그램, 비주기성을 DataPacket으로 출력. WorldSynthesisNode는 이를 받아 최종 WAV 생성. 실시간 처리와 배치 처리 모두 지원.",
        "testStrategy": "알려진 샘플 오디오로 분석-합성 결과 비교, 원본과 재합성 음성의 품질 측정 (PESQ, STOI), 처리 시간 벤치마크",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "WORLD 알고리즘 논문 분석 및 핵심 구성 요소 설계",
            "description": "WORLD 보코더의 DIO, Harvest, CheapTrick, D4C 알고리즘을 분석하여 WorldAnalysisNode와 WorldSynthesisNode의 기본 구조를 설계",
            "dependencies": [],
            "details": "WORLD 논문 및 기술 문서를 분석하여 F0 추출 알고리즘 (DIO, Harvest), 스펙트럼 분석 알고리즘 (CheapTrick), 비주기성 지표 알고리즘 (D4C)의 수학적 원리와 구현 방법을 이해. include/world/WorldAnalysisNode.h와 WorldSynthesisNode.h 헤더 파일에 클래스 인터페이스 정의. ISynthesisNode를 상속받아 process(), initialize() 메서드 선언. 각 알고리즘에 필요한 파라미터 구조체 및 데이터 플로우 설계",
            "status": "done",
            "testStrategy": "WORLD 알고리즘의 이론적 이해도 검증을 위한 문서 작성, 인터페이스 설계의 일관성 검토"
          },
          {
            "id": 2,
            "title": "F0 추출 알고리즘 (DIO, Harvest) 구현",
            "description": "WORLD의 핵심 구성 요소인 DIO와 Harvest 알고리즘을 구현하여 기본 주파수(F0) 추출 기능을 제공",
            "dependencies": [
              "3.1"
            ],
            "details": "src/world/F0Extraction.cpp에 DIO 및 Harvest 알고리즘 구현. DIO는 사인파 기반 F0 추정 방법으로 저품질/고속 처리 모드, Harvest는 고품질 F0 추출 방법으로 정밀 분석 모드 구현. 피치 트랙킹, 보이스/언보이스 판정, 시간 축 기반 F0 곡선 생성. 오디오 입력 신호에서 프레임 단위로 F0 값을 추출하여 vector<double> 형태로 반환하는 함수 구현",
            "status": "done",
            "testStrategy": "알려진 피치를 가진 테스트 신호로 F0 추출 정확도 측정, 다양한 음성 샘플에서 피치 트랙킹 성능 검증"
          },
          {
            "id": 3,
            "title": "스펙트럼 분석 알고리즘 (CheapTrick) 및 비주기성 지표 (D4C) 구현",
            "description": "WORLD의 스펙트럼 포락선 추출과 비주기성 지표 계산을 위한 CheapTrick과 D4C 알고리즘을 구현",
            "dependencies": [
              "3.2"
            ],
            "details": "src/world/SpectralAnalysis.cpp에 CheapTrick 알고리즘 구현하여 F0 정보를 기반으로 스펙트럼 포락선(spectral envelope) 추출. FFT 기반 주파수 도메인 분석, 케프스트럼 평활화 기법 적용. src/world/D4C.cpp에 D4C 알고리즘 구현하여 비주기성 지표(aperiodicity) 계산. 조화성분과 잡음성분을 분리하여 음성의 브리더니스(breathiness) 특성 모델링",
            "status": "done",
            "testStrategy": "합성된 사인파 신호로 스펙트럼 추출 정확도 검증, 다양한 음성 샘플의 비주기성 지표 일관성 확인"
          },
          {
            "id": 4,
            "title": "WorldAnalysisNode 구현 및 분석 파이프라인 통합",
            "description": "WAV 입력을 받아 F0, 스펙트로그램, 비주기성을 DataPacket으로 출력하는 WorldAnalysisNode 완전 구현",
            "dependencies": [
              "3.2",
              "3.3"
            ],
            "details": "src/world/WorldAnalysisNode.cpp에 ISynthesisNode를 상속받는 완전한 분석 노드 구현. process() 메서드에서 입력 WAV 데이터를 받아 F0 추출, 스펙트럼 분석, 비주기성 계산을 순차 수행. 결과를 DataPacket에 구조화하여 후속 노드로 전달. 실시간 처리를 위한 프레임 기반 처리와 배치 처리 모드 지원. 샘플레이트, 프레임 길이 등 파라미터 설정 인터페이스 제공",
            "status": "done",
            "testStrategy": "다양한 길이와 품질의 WAV 파일로 분석 결과 검증, DataPacket 직렬화/역직렬화 정확성 확인"
          },
          {
            "id": 5,
            "title": "WorldSynthesisNode 구현 및 파형 재합성 기능 완성",
            "description": "F0, 스펙트로그램, 비주기성 정보를 받아 최종 WAV 파형을 생성하는 WorldSynthesisNode 구현 및 전체 분석-합성 파이프라인 완성",
            "dependencies": [
              "3.4"
            ],
            "details": "src/world/WorldSynthesisNode.cpp에 WORLD 합성 알고리즘 구현. DataPacket에서 F0, 스펙트럼 포락선, 비주기성 지표를 추출하여 시간 도메인 파형으로 재합성. Minimum-phase 필터링, 소스-필터 모델 기반 합성, 윈도우 함수 적용한 오버랩-애드 처리. 실시간 스트리밍과 배치 처리 모드 모두 지원. 품질-속도 트레이드오프를 위한 설정 옵션 제공",
            "status": "done",
            "testStrategy": "원본 음성과 분석-합성 결과의 품질 비교 (PESQ, STOI 측정), 처리 시간 벤치마크, 메모리 사용량 모니터링"
          },
          {
            "id": 6,
            "title": "WorldSynthesisNode에 포스트필터 훅 추가",
            "description": "포먼트 시프팅/UV 조정 등 선택적 후처리를 위한 훅 포인트를 WorldSynthesisNode에 추가하고 기본값은 완전 바이패스.",
            "details": "WorldSynthesisNode::process() 최종 출력 직전에 후처리 체인을 연결할 수 있는 훅을 추가합니다.\n- 인터페이스: IPostFilter(prepare(sampleRate, channels), process(float* interleaved, frames), reset()) 정의\n- 파이프라인: 합성 결과 버퍼 → (옵션) 포스트필터 체인 → 출력\n- 구성: DataPacket 혹은 노드 설정으로 필터 on/off 및 파라미터(formantShift, uvBalance 등) 전달\n- 기본값: 필터 체인 비워진 상태로 완전 바이패스(연산 오버헤드 최소화)\n- 성능: 큰 버퍼에서는 블록 처리, 실시간 경로에서는 작은 청크 처리와 lock-free 큐 고려\n- 안전성: 파라미터 변경 시 thread-safe 스냅샷 교체(더블 버퍼링)로 글리치 방지\n<info added on 2025-08-10T08:16:01.186Z>\nNext: add a minimal DummyGainFilter for unit testing and write tests: (1) bypass equality within epsilon, (2) gain!=1 changes level.\n</info added on 2025-08-10T08:16:01.186Z>",
            "testStrategy": "단위: (1) 바이패스 시 입력==출력(허용 오차 내) 확인, (2) 더미 필터(고정 게인) 적용 시 스펙트럼/레벨 변화 검증\n통합: WORLD 합성 경로에 필터 체인 삽입 후 라운드트립 품질/지연 측정\n성능: 필터 on/off 상태에서 CPU 사용률, 처리 시간 측정(프레임 크기별)",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "WAV 파일 I/O 및 오디오 처리 유틸리티 구현",
        "description": "크로스플랫폼 WAV 파일 읽기/쓰기 기능과 기본적인 오디오 신호 처리 유틸리티 함수들을 구현",
        "details": "WAV 파일 헤더 파싱 및 생성, 다양한 샘플레이트/비트깊이 지원 (16-bit, 24-bit, 32-bit float), 스테레오/모노 변환, 리샘플링 기능, 윈도우 함수 (Hanning, Hamming, Blackman), FFT/IFFT 래퍼, 오디오 버퍼 관리 클래스. 플랫폼별 엔디안 처리.",
        "testStrategy": "다양한 형식의 WAV 파일 읽기/쓰기 테스트, 오디오 신호 변환 정확성 검증, 메모리 사용량 모니터링",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "WAV 파일 헤더 파싱 및 생성 유틸리티 구현",
            "description": "WAV 파일의 RIFF 헤더 구조를 파싱하고 생성하는 기본 유틸리티 함수들을 구현합니다. 다양한 비트 깊이와 샘플레이트를 지원하는 헤더 구조체를 정의합니다.",
            "dependencies": [],
            "details": "WavHeader 구조체 정의 (RIFF, WAVE, fmt, data 청크), 엔디안 변환 함수, 헤더 유효성 검증, 16-bit/24-bit/32-bit float PCM 포맷 지원. include/audio/wav_io.h와 src/audio/wav_io.cpp 파일 생성. 플랫폼별 바이트 순서 처리를 위한 매크로 정의.\n<info added on 2025-08-09T18:00:28.006Z>\nWAV 헤더 관련 구조체는 `RiffHeader`, `ChunkHeader`, `FmtPCM`, `WavInfo`, `WavData`로 구체화되었으며, `WavReader` 및 `WavWriter` 클래스가 각각 open/rewind/readFrames/readAll/info, open/writeFrames/close 메서드와 함께 구현되었습니다. 지원 포맷은 PCM16, PCM24(3바이트 sign-extend), IEEE Float32이며, 엔디안은 WAV 표준에 따라 리틀엔디안을 가정하고 타겟 플랫폼(리눅스/x86)에 맞춰 추가 변환은 미적용됩니다. 헤더 유효성 검증은 청크 검증과 함께 사이즈 추적을 포함하며, `WavWriter`는 `close` 시 RIFF 및 data 청크 사이즈를 패치합니다. 모든 읽기 작업(`readAll`/`readFrames`) 결과는 `float(-1..1)` 범위로 변환됩니다. 파일 경로는 `include/utils/WavIO.h`와 `src/utils/WavIO.cpp`로 변경되었습니다.\n</info added on 2025-08-09T18:00:28.006Z>",
            "status": "done",
            "testStrategy": "다양한 포맷의 WAV 파일 헤더 파싱 테스트, 잘못된 헤더에 대한 에러 처리 검증"
          },
          {
            "id": 2,
            "title": "WAV 파일 읽기 기능 구현",
            "description": "WAV 파일에서 오디오 데이터를 읽어오는 기능을 구현합니다. 다양한 포맷의 WAV 파일을 지원하고 오디오 버퍼로 로드하는 기능을 제공합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "WavReader 클래스 구현, 파일 스트림 처리, 청크별 데이터 읽기, 샘플 포맷 변환 (int16 → float, int24 → float, float32), 스테레오/모노 채널 처리. 대용량 파일을 위한 스트리밍 읽기 지원. 메모리 효율적인 버퍼 관리.\n<info added on 2025-08-09T18:06:44.598Z>\n추가적으로, `readAll` 및 `readFrames` 메서드를 통한 전체/스트리밍 읽기 지원이 구현되었으며, `int24` 포맷은 자체 변환 로직을 사용하고 `float32` 포맷은 클램핑하여 변환됩니다. 채널 데이터는 인터리브 형식을 유지하며 `channels` 필드를 반영합니다. 또한, `tests/test_core.cpp`에 16-bit 라운드트립 간이 검증 로직이 추가되었습니다.\n</info added on 2025-08-09T18:06:44.598Z>",
            "status": "done",
            "testStrategy": "표준 WAV 파일들로 읽기 정확성 테스트, 메모리 사용량 모니터링, 대용량 파일 스트리밍 테스트"
          },
          {
            "id": 3,
            "title": "WAV 파일 쓰기 기능 구현",
            "description": "오디오 버퍼 데이터를 WAV 파일 포맷으로 저장하는 기능을 구현합니다. 다양한 비트 깊이와 샘플레이트로 출력할 수 있도록 합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "WavWriter 클래스 구현, 헤더 생성 및 쓰기, 오디오 데이터 포맷 변환 (float → int16/int24/float32), 파일 크기 계산 및 헤더 업데이트. 실시간 쓰기를 위한 버퍼링 지원. 파일 무결성 보장을 위한 예외 처리.\n<info added on 2025-08-09T18:18:52.484Z>\n, WavWriter 클래스는 `open()`, `writeFrames()`, `close()` 메서드를 포함하며, 32-float는 IEEE_FLOAT 포맷으로 지원한다. 정수 PCM 경로에서는 `peakNormalize` 옵션을 통한 스케일링 후 양자화를 수행한다. 24비트 데이터는 3바이트 little-endian으로 작성하며, `close()` 메서드에서 data size와 RIFF size를 패치하여 헤더를 업데이트한다. 편의 함수 `writeWav16` 및 `writeWav32f`를 추가하고 (기존 `writeWav16` 호환 유지), CMake에서 `src/utils/WavIO.cpp`를 `voceversa_core`에 링크한다.\n</info added on 2025-08-09T18:18:52.484Z>",
            "status": "done",
            "testStrategy": "생성된 WAV 파일의 다른 소프트웨어 호환성 테스트, 포맷별 출력 품질 검증"
          },
          {
            "id": 4,
            "title": "오디오 버퍼 관리 및 기본 신호 처리 유틸리티 구현",
            "description": "오디오 데이터를 효율적으로 관리하는 AudioBuffer 클래스와 스테레오/모노 변환, 리샘플링 등 기본 신호 처리 기능을 구현합니다.",
            "dependencies": [
              "4.2",
              "4.3"
            ],
            "details": "AudioBuffer 클래스 (멀티채널 지원, 샘플 인덱싱, 메모리 관리), 스테레오↔모노 변환, 선형/큐빅 보간 리샘플링, 게인 조절, 믹싱 기능. 템플릿 기반으로 float/double 정밀도 지원. SIMD 최적화 고려사항 포함.\n<info added on 2025-08-09T18:20:11.618Z>\nAudioBuffer<T>는 header-only로 include/utils/AudioBuffer.h에 구현되며, 멀티채널 인터리브 버퍼를 지원합니다. SignalUtils 클래스는 include/utils/SignalUtils.h에 구현되어 Hanning/Hamming/Blackman 윈도우 생성 및 resampleLinear 함수를 통한 선형 리샘플링 기능을 제공합니다. 기본 정밀도는 float입니다. test_core.cpp에 윈도우 함수 및 간단한 기능 검증 테스트가 추가됩니다.\n</info added on 2025-08-09T18:20:11.618Z>",
            "status": "done",
            "testStrategy": "신호 변환 정확성 검증, 리샘플링 품질 테스트, 메모리 누수 검사"
          },
          {
            "id": 5,
            "title": "윈도우 함수 및 FFT 래퍼 구현",
            "description": "주파수 도메인 분석을 위한 윈도우 함수들(Hanning, Hamming, Blackman)과 FFT/IFFT 기능을 구현합니다.",
            "dependencies": [
              "4.4"
            ],
            "details": "WindowFunction 클래스로 다양한 윈도우 타입 지원, FFTW3 또는 KissFFT 라이브러리 통합, FFTWrapper 클래스로 forward/inverse 변환, 복소수 데이터 처리, 제로 패딩 및 윈도우 적용 자동화. 실시간 처리를 위한 STFT 기능 포함.\n<info added on 2025-08-09T18:20:32.542Z>\nWindow 함수 (Hanning, Hamming, Blackman)가 SignalUtils에 구현되었습니다. FFTWrapper (include/utils/FFTWrapper.h)는 radix-2 Cooley-Tukey 알고리즘을 사용하여 power-of-two 크기만 지원하며, fft/ifft 가역성 테스트가 추가되었습니다. 향후 FFTW/KissFFT 라이브러리로의 교체가 용이하도록 래퍼 형태가 유지되었습니다.\n</info added on 2025-08-09T18:20:32.542Z>",
            "status": "done",
            "testStrategy": "윈도우 함수 수학적 정확성 검증, FFT 변환 결과 검증, 성능 벤치마크"
          }
        ]
      },
      {
        "id": 5,
        "title": "PSOLA 기반 유닛 선택 합성 시스템 구현",
        "description": "PSOLA(Pitch Synchronous Overlap and Add) 알고리즘을 구현하고, 음성 단위 데이터베이스 관리 및 유닛 선택 기능을 포함한 UnitSelectionNode와 PsolaSynthesisNode 개발",
        "details": "PSOLA 알고리즘 논문 분석 및 구현: 피치 마킹, 파형 분할, OLA(Overlap-Add) 처리. UnitSelectionNode는 diphone/triphone 단위로 구성된 음성 DB에서 목표 음소, 피치, 길이에 최적인 유닛 선택 (비용 함수 기반). PsolaSynthesisNode는 선택된 유닛들을 목표 파라미터에 맞춰 시간축/주파수축 변형 후 자연스럽게 연결. 음성 DB 인덱싱 및 빠른 검색 구조.",
        "testStrategy": "합성된 음성의 자연스러움 평가, 다양한 언어/발음에 대한 유닛 선택 정확성 검증, 실시간 처리 성능 측정",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "PSOLA 피치 마킹 및 분석 모듈 구현",
            "description": "PSOLA 알고리즘의 핵심인 피치 동기화 포인트 검출 및 파형 분할을 위한 피치 마킹 시스템 구현",
            "dependencies": [],
            "details": "자기상관 함수 또는 AMDF(Average Magnitude Difference Function) 기반 피치 추정 알고리즘 구현. 피치 마크 위치에서 파형을 분할하는 윈도우 함수 적용. 피치 주기 검증 및 보정 로직 포함. PitchMarker 클래스와 관련 유틸리티 함수들을 src/psola/ 디렉토리에 구현.",
            "status": "pending",
            "testStrategy": "알려진 피치의 합성 사인파 신호로 피치 검출 정확도 테스트, 실제 음성 파일의 수동 라벨링과 비교 검증"
          },
          {
            "id": 2,
            "title": "음성 단위 데이터베이스 구조 및 인덱싱 시스템 개발",
            "description": "diphone/triphone 단위로 구성된 음성 데이터베이스의 저장, 검색, 인덱싱을 위한 효율적인 자료구조 구현",
            "dependencies": [],
            "details": "UnitDatabase 클래스 구현: 음소 정보, 피치, 길이, 음향 특성을 포함한 메타데이터와 실제 오디오 세그먼트 저장. B-tree 또는 해시맵 기반 빠른 검색 구조. 음성 단위의 음향적 특성(F0 평균, 스펙트럼 중심, 지속시간) 추출 및 저장. JSON 또는 바이너리 형식의 데이터베이스 파일 포맷 설계.",
            "status": "pending",
            "testStrategy": "다양한 크기의 데이터베이스로 검색 속도 벤치마크, 메모리 사용량 최적화 검증, 데이터 무결성 테스트"
          },
          {
            "id": 3,
            "title": "유닛 선택 비용 함수 및 UnitSelectionNode 구현",
            "description": "목표 음향 파라미터와 데이터베이스 유닛 간의 최적 매칭을 위한 비용 함수 기반 유닛 선택 알고리즘 구현",
            "dependencies": [
              "5.2"
            ],
            "details": "Target cost(목표 피치, 길이와의 차이)와 Join cost(인접 유닛 간 연결 비용) 계산. 다차원 거리 함수 구현: 피치 차이, 스펙트럼 거리, 길이 비율 등을 가중합으로 계산. Viterbi 디코딩 또는 A* 탐색으로 최적 유닛 시퀀스 선택. UnitSelectionNode 클래스에서 음소열과 목표 운율 정보를 받아 최적 유닛 목록 출력.",
            "status": "pending",
            "testStrategy": "동일 문장의 다른 운율 조건에서 유닛 선택 일관성 검증, 비용 함수 파라미터 튜닝을 통한 음질 개선 측정"
          },
          {
            "id": 4,
            "title": "PSOLA 시간축/주파수축 변형 엔진 구현",
            "description": "선택된 음성 유닛들을 목표 피치와 지속시간에 맞춰 변형하는 PSOLA 기반 신호 처리 엔진 개발",
            "dependencies": [
              "5.1"
            ],
            "details": "TD-PSOLA(Time-Domain PSOLA) 구현: 피치 마크 기반 파형 세그먼트 추출, 목표 피치에 따른 세그먼트 간격 조정, 목표 지속시간에 따른 세그먼트 반복/제거. Overlap-Add 윈도우 함수 적용으로 자연스러운 연결. PsolaEngine 클래스에서 피치 스케일링, 시간 스케일링, 크로스페이딩 처리.",
            "status": "pending",
            "testStrategy": "다양한 피치/시간 변형률에서 합성 품질 평가, 아티팩트(glitch) 검출, 원본 대비 스펙트럼 왜곡 측정"
          },
          {
            "id": 5,
            "title": "PsolaSynthesisNode 통합 및 실시간 처리 최적화",
            "description": "유닛 선택과 PSOLA 변형을 통합한 완전한 합성 노드 구현 및 실시간 처리를 위한 성능 최적화",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "PsolaSynthesisNode 클래스에서 UnitSelectionNode 결과를 받아 PSOLA 변형 후 최종 오디오 출력. 스트리밍 처리를 위한 버퍼링 및 청크 단위 처리. 멀티스레딩을 통한 유닛 선택과 파형 합성의 파이프라인 병렬화. 메모리 풀링과 캐싱으로 실시간 처리 성능 확보. 품질/속도 트레이드오프 조절 파라미터 제공.",
            "status": "pending",
            "testStrategy": "실시간 합성 지연시간 측정, CPU/메모리 사용률 프로파일링, 다양한 텍스트 길이에서 처리 속도 일관성 검증, 주관적 음질 평가"
          }
        ]
      },
      {
        "id": 6,
        "title": "LLSM2 통계 기반 파라미터 생성 모델 구현",
        "description": "LLSM(Low-Level Speech Model) 2 알고리즘을 분석하고 LlsmModelNode로 구현하여 통계 기반 스펙트럼 파라미터 생성 기능 제공",
        "details": "LLSM2 논문 기반 알고리즘 분석: 조화성분과 잡음성분 분리, 스펙트럼 파라미터 모델링, HNM(Harmonic plus Noise Model) 구현. LlsmModelNode는 UTAU 스타일 파라미터(음높이, 발음, 길이 등)를 입력받아 통계적 모델을 통해 스펙트럼 파라미터 생성. 기존 UTAU 보이스 뱅크와의 호환성 고려한 파라미터 매핑.",
        "testStrategy": "기존 UTAU 결과와 품질 비교, 다양한 파라미터 조합에 대한 출력 일관성 검증, 처리 속도 벤치마크",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "LLSM2 알고리즘 논문 분석 및 수학적 모델링",
            "description": "LLSM2 논문을 상세히 분석하여 조화성분과 잡음성분 분리 알고리즘, HNM 모델의 수학적 기반을 이해하고 구현 계획 수립",
            "dependencies": [],
            "details": "LLSM2 논문의 핵심 알고리즘 분석: 조화성분 추출을 위한 피치 추정 방법, 잡음성분 모델링을 위한 스펙트럼 분석, HNM 모델의 매개변수 추정 방법. 수학적 공식들을 C++ 구현 가능한 형태로 변환하고, 필요한 외부 라이브러리 (FFTW, Eigen 등) 조사. 알고리즘의 계산 복잡도 분석 및 실시간 처리 가능성 검토.",
            "status": "pending",
            "testStrategy": "논문의 예제 데이터를 통한 알고리즘 정확성 검증, 기준 구현체와의 결과 비교"
          },
          {
            "id": 2,
            "title": "조화성분 분석 및 추출 모듈 구현",
            "description": "음성 신호에서 피치 추정을 통해 조화성분을 분리하고 분석하는 핵심 모듈 구현",
            "dependencies": [
              "6.1"
            ],
            "details": "HarmonicAnalyzer 클래스 구현: 자기상관함수 기반 피치 추정, 조화성분 추출을 위한 코움 필터링, 조화성분의 진폭과 위상 추정. STFT 기반 스펙트럼 분석과 조화성분 템플릿 매칭. 음성의 유성음/무성음 분류 및 조화성 정도 측정. 시간에 따른 피치 변화 추적 및 smoothing 알고리즘 적용.",
            "status": "pending",
            "testStrategy": "다양한 화자의 음성에 대한 피치 추정 정확도 측정, 조화성분 분리 품질 평가"
          },
          {
            "id": 3,
            "title": "잡음성분 모델링 및 스펙트럼 파라미터 생성",
            "description": "조화성분을 제거한 잔여 신호에서 잡음성분을 모델링하고 스펙트럼 파라미터를 생성하는 모듈 구현",
            "dependencies": [
              "6.2"
            ],
            "details": "NoiseAnalyzer 클래스 구현: 조화성분 제거 후 잔여 신호 분석, 잡음성분의 스펙트럼 포락선 추정, LPC 분석을 통한 포르만트 추출. 스펙트럼 파라미터 벡터 생성 (멜 스케일 기반), 시간적 변화에 따른 파라미터 보간. 잡음성분의 에너지 분포 분석 및 주파수 대역별 모델링.",
            "status": "pending",
            "testStrategy": "잡음성분 모델링 정확도 검증, 재합성된 음성의 품질 평가"
          },
          {
            "id": 4,
            "title": "UTAU 파라미터 매핑 및 호환성 레이어 구현",
            "description": "UTAU 스타일 파라미터를 LLSM2 내부 파라미터로 변환하는 매핑 시스템과 호환성 레이어 구현",
            "dependencies": [
              "6.2",
              "6.3"
            ],
            "details": "UtauParameterMapper 클래스 구현: UTAU 음높이 파라미터를 LLSM2 피치 파라미터로 변환, 발음 길이를 시간축 스케일링 파라미터로 매핑, 음량을 진폭 파라미터로 변환. 기존 UTAU 보이스뱅크 메타데이터 파싱 및 LLSM2 파라미터 공간으로의 정규화. 파라미터 보간 및 smooth transition 처리.",
            "status": "pending",
            "testStrategy": "기존 UTAU 보이스뱅크와의 파라미터 변환 정확성 검증, 호환성 테스트"
          },
          {
            "id": 5,
            "title": "LlsmModelNode 통합 구현 및 최적화",
            "description": "앞서 구현한 모든 모듈을 통합하여 LlsmModelNode를 완성하고 성능 최적화 수행",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "LlsmModelNode 클래스 완성: ISynthesisNode 인터페이스 구현, 조화성분/잡음성분 분석기 통합, 실시간 스펙트럼 파라미터 생성 파이프라인 구축. 메모리 풀 기반 버퍼 관리, 멀티스레딩을 통한 병렬 처리 최적화. 캐싱 메커니즘을 통한 반복 계산 최소화, SIMD 명령어를 활용한 벡터 연산 최적화.",
            "status": "pending",
            "testStrategy": "전체 시스템 통합 테스트, 실시간 처리 성능 벤치마크, 메모리 사용량 및 CPU 부하 측정"
          }
        ]
      },
      {
        "id": 7,
        "title": "UTAU 호환 어댑터 및 플러그인 인터페이스 구현",
        "description": "UTAU 프런트엔드와의 호환성을 위한 UtauAdapter 구현 및 resampler.exe/wavtool.exe 규격에 맞는 실행 파일 생성",
        "details": "world4utau 동작 분석하여 UTAU 임시 파일 형식 (.wav, .frq, .llsm) 파싱, 커맨드라인 파라미터 처리, 배치 파일 기반 호출 방식 지원. UtauAdapter 클래스로 UTAU 파라미터를 내부 DataPacket으로 변환, 다양한 합성 백엔드 (WORLD, PSOLA, LLSM2) 선택 가능한 설정 파일 지원. Windows 실행 파일 (.exe) 생성 및 UTAU 플러그인 디렉토리 설치 스크립트.",
        "testStrategy": "실제 UTAU 프로젝트에서 플러그인 동작 테스트, 기존 resampler와 출력 비교, 다양한 UTAU 버전 호환성 검증",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "UTAU 파라미터 파싱 및 임시 파일 처리 구현",
            "description": "UTAU가 생성하는 임시 파일(.wav, .frq, .llsm)과 커맨드라인 파라미터를 분석하고 파싱하는 시스템 구현",
            "dependencies": [],
            "details": "world4utau 동작 방식을 참조하여 UTAU 호환 파라미터 분석기를 구현합니다. 커맨드라인 파라미터 처리 (음소, 길이, 피치, 플래그 등), 임시 디렉토리에서 .wav/.frq/.llsm 파일 읽기, 배치 파일 기반 호출 방식 지원을 포함합니다. UtauParameter 구조체와 파일 파서 클래스를 작성하여 내부 DataPacket 형태로 변환할 준비를 합니다.",
            "status": "pending",
            "testStrategy": "다양한 UTAU 파라미터 조합에 대한 파싱 테스트, 임시 파일 형식 검증, 실제 UTAU 환경에서 생성된 파일들로 호환성 확인"
          },
          {
            "id": 2,
            "title": "UtauAdapter 클래스 구현",
            "description": "UTAU 파라미터를 내부 DataPacket으로 변환하고 다양한 합성 백엔드를 선택할 수 있는 어댑터 클래스 구현",
            "dependencies": [
              "7.1"
            ],
            "details": "UtauAdapter 클래스를 구현하여 파싱된 UTAU 파라미터를 ISynthesisNode 체계의 DataPacket으로 변환합니다. WORLD, PSOLA, LLSM2 등 다양한 합성 백엔드를 선택할 수 있는 설정 시스템을 구축하고, 백엔드별 파라미터 매핑 로직을 구현합니다. 설정 파일 기반 백엔드 전환 기능과 ComputationGraph 생성 로직을 포함합니다.",
            "status": "pending",
            "testStrategy": "각 백엔드별 변환 정확성 테스트, 설정 파일 기반 백엔드 전환 테스트, 생성된 ComputationGraph 유효성 검증"
          },
          {
            "id": 3,
            "title": "UTAU 호환 실행 파일 생성 시스템 구현",
            "description": "resampler.exe/wavtool.exe 규격에 맞는 Windows 실행 파일을 생성하는 빌드 시스템 구현",
            "dependencies": [
              "7.2"
            ],
            "details": "CMake 설정을 확장하여 UTAU 플러그인 규격에 맞는 resampler.exe와 wavtool.exe를 빌드할 수 있도록 합니다. Windows 전용 빌드 타겟 생성, 적절한 링크 옵션 설정, 콘솔 애플리케이션 형태의 main() 함수 구현을 포함합니다. 생성된 실행 파일이 UTAU에서 올바르게 인식되고 동작하도록 파일 속성과 메타데이터를 설정합니다.",
            "status": "pending",
            "testStrategy": "생성된 실행 파일의 UTAU 인식 테스트, 파일 크기와 의존성 최적화 확인, Windows 버전별 호환성 검증"
          },
          {
            "id": 4,
            "title": "UTAU 플러그인 디렉토리 자동 설치 스크립트 구현",
            "description": "빌드된 플러그인을 UTAU 플러그인 디렉토리에 자동으로 설치하는 스크립트 시스템 구현",
            "dependencies": [
              "7.3"
            ],
            "details": "Windows 환경에서 UTAU 설치 경로를 자동 감지하고 플러그인을 올바른 디렉토리에 배포하는 설치 스크립트를 작성합니다. 레지스트리 검색을 통한 UTAU 경로 자동 감지, 플러그인 백업 및 복원 기능, 설치/제거 배치 파일 생성을 포함합니다. 사용자 권한 문제를 고려한 안전한 파일 복사 로직을 구현합니다.",
            "status": "pending",
            "testStrategy": "다양한 UTAU 버전과 설치 경로에서의 자동 감지 테스트, 설치/제거 기능 검증, 사용자 권한별 동작 확인"
          },
          {
            "id": 5,
            "title": "통합 테스트 및 UTAU 호환성 검증",
            "description": "실제 UTAU 환경에서 구현된 어댑터와 플러그인의 전체적인 동작을 검증하는 종합 테스트 수행",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "실제 UTAU 프로젝트 파일을 사용하여 전체 파이프라인 테스트를 수행합니다. 기존 resampler와 출력 품질 비교, 다양한 UTAU 버전 (UTAU-SYNTH, OpenUTAU 등)에서의 호환성 검증, 성능 벤치마크를 실시합니다. 에러 처리 및 로깅 시스템 검증, 메모리 사용량 최적화 확인을 포함하여 안정성과 품질을 보장합니다.",
            "status": "pending",
            "testStrategy": "실제 UTAU 프로젝트에서의 end-to-end 테스트, 기존 플러그인과의 품질 비교 분석, 다양한 합성 설정에서의 안정성 검증"
          },
          {
            "id": 6,
            "title": "Manifest 기반 인자 파싱 연동",
            "description": "OpenUtau Resampler Manifest(YAML) 정의에 맞춘 커맨드라인/환경 인자 파싱 계층 추가",
            "details": "resampler.yaml 스키마에 따라 지원 인자/기본값/범위를 선언하고, 이를 기반으로 CLI/환경변수 파싱 계층을 생성합니다.\n- 스키마: name, version, args{name,type,default,range,alias}, envVars, presets\n- 파싱: CLI → 내부 Config 구조체 매핑, 누락 시 env/preset/기본값 순으로 보완\n- 검증: 범위/타입/상호 제약 검증 및 친절한 에러 메시지 제공\n- 버전: manifest 버전 관리와 비호환 변경시 경고/차단 정책",
            "testStrategy": "단위: 정상/경계/에러 케이스 YAML 파싱 및 CLI 인자 조합 검증\n통합: manifest → CLI 플래그 자동화 테스트(스냅샷), 비호환 변경 시 경고 발생 확인",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 7,
            "title": "OpenUtau Runner 호환 래퍼",
            "description": "OpenUtau에서 호출되는 실행 시나리오를 재현하는 간이 래퍼/샌드박스 추가",
            "details": "OpenUtau가 resampler를 호출하는 런타임 환경을 모사하는 래퍼를 구현합니다.\n- 기능: 인자/환경 구성, 임시 파일 경로 정책, 타임아웃/로그 캡처\n- 샌드박스: 테스트 입력(.ust/.wav)으로 재현 가능한 호출 세트 제공\n- 로깅: 호출 라인, 지속시간, 표준출력/표준에러 수집",
            "testStrategy": "기능: 대표 호출 시나리오(기본/플래그/긴 구간) 스모크 테스트\n호환: 실제 OpenUtau 호출 로그와 래퍼 재현 로그를 비교해 불일치 탐지",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "ONNX Runtime 통합 및 딥러닝 추론 노드 구현",
        "description": "ONNX Runtime을 통합하고 OnnxInferenceNode를 구현하여 DiffSinger 등 딥러닝 모델을 지원하는 추론 파이프라인 구축",
        "details": "ONNX Runtime C++ API 통합, 동적 모델 로딩, GPU/CPU 백엔드 자동 선택, 텐서 데이터 타입 변환 (float32, int64 등). OnnxInferenceNode는 .onnx 모델 경로와 입력 텐서를 DataPacket으로 받아 추론 수행 후 결과 텐서 반환. DiffSinger 아키텍처 분석하여 어쿠스틱 모델 (음소→멜스펙트로그램)과 보코더 모델 (멜→파형) 지원. 배치 추론 및 스트리밍 추론 모드.",
        "testStrategy": "사전 학습된 DiffSinger 모델로 추론 테스트, GPU/CPU 성능 비교, 메모리 사용량 최적화 검증",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ONNX Runtime C++ 라이브러리 통합 및 기본 환경 설정",
            "description": "ONNX Runtime C++ API를 프로젝트에 통합하고 GPU/CPU 백엔드 자동 선택 기능을 구현",
            "dependencies": [],
            "details": "CMakeLists.txt에 ONNX Runtime 의존성 추가, GPU 사용 가능 여부 자동 감지하여 ExecutionProvider 선택 (CUDA, DirectML, CPU), 초기화 및 정리 함수 구현, 런타임 버전 호환성 검증 로직 포함",
            "status": "pending",
            "testStrategy": "GPU/CPU 환경에서 ONNX Runtime 초기화 성공 여부 테스트, 메모리 누수 검증"
          },
          {
            "id": 2,
            "title": "텐서 데이터 타입 변환 및 메모리 관리 유틸리티 구현",
            "description": "ONNX 텐서와 내부 데이터 구조 간 변환을 위한 유틸리티 클래스 구현",
            "dependencies": [
              "8.1"
            ],
            "details": "float32, int64, string 등 ONNX 지원 데이터 타입 변환 함수, DataPacket과 Ort::Value 간 상호 변환, 텐서 shape 검증 및 배치 처리를 위한 동적 크기 조정, 메모리 풀링을 통한 성능 최적화",
            "status": "pending",
            "testStrategy": "다양한 데이터 타입 변환 정확성 테스트, 대용량 텐서 처리 시 메모리 사용량 모니터링"
          },
          {
            "id": 3,
            "title": "OnnxInferenceNode 기본 구조 및 모델 로딩 구현",
            "description": "ProcessorNode를 상속받는 OnnxInferenceNode 클래스 구현 및 동적 ONNX 모델 로딩 기능",
            "dependencies": [
              "8.2"
            ],
            "details": "ProcessorNode 인터페이스 구현, .onnx 파일 경로를 통한 동적 모델 로딩, 입력/출력 텐서 메타데이터 추출 및 검증, 모델별 세션 캐싱으로 재로딩 최적화, 스레드 안전성 보장",
            "status": "pending",
            "testStrategy": "다양한 ONNX 모델 로딩 테스트, 잘못된 모델 파일에 대한 에러 처리 검증"
          },
          {
            "id": 4,
            "title": "DiffSinger 아키텍처 분석 및 어쿠스틱/보코더 모델 지원",
            "description": "DiffSinger의 어쿠스틱 모델과 보코더 모델을 위한 특화된 추론 파이프라인 구현",
            "dependencies": [
              "8.3"
            ],
            "details": "DiffSinger 입력 형식 분석 (음소 시퀀스, 피치, 듀레이션), 어쿠스틱 모델용 전처리 (음소→토큰 변환, 피치 정규화), 보코더 모델용 멜스펙트로그램 처리, 모델별 추론 설정 및 하이퍼파라미터 관리",
            "status": "pending",
            "testStrategy": "실제 DiffSinger 모델로 음소→멜스펙트로그램→파형 변환 테스트, 출력 품질 검증"
          },
          {
            "id": 5,
            "title": "배치 추론 및 스트리밍 추론 모드 구현",
            "description": "실시간 스트리밍과 배치 처리를 모두 지원하는 추론 모드 구현",
            "dependencies": [
              "8.4"
            ],
            "details": "배치 추론: 전체 시퀀스를 한 번에 처리하여 최대 성능 달성, 스트리밍 추론: 청크 단위 실시간 처리로 지연시간 최소화, 상태 관리를 통한 연속적인 추론, 동적 배치 크기 조정 및 메모리 사용량 최적화",
            "status": "pending",
            "testStrategy": "실시간 추론 지연시간 측정, 배치 처리 throughput 벤치마크, 긴 시퀀스에서의 메모리 안정성 테스트"
          }
        ]
      },
      {
        "id": 9,
        "title": "범용 C-ABI 공개 API 설계 및 구현",
        "description": "UTAU 외 프런트엔드 연동을 위한 C-ABI 호환 공개 API (PublicCApi.h) 설계 및 구현",
        "details": "C 스타일 API 인터페이스로 언어별 바인딩 지원 (Python, JavaScript, C# 등), 구조화된 입력 데이터 (노트 시퀀스, 가사, 발음 기호, 피치 커브, 컨트롤 파라미터), 비동기 처리 지원, 콜백 함수 기반 진행률 모니터링, 에러 핸들링 및 상태 코드 정의. 동적 라이브러리 (.so, .dll, .dylib) 빌드 설정, 헤더 파일 공개 인터페이스 명세.",
        "testStrategy": "다양한 언어에서 API 바인딩 테스트, 대용량 데이터 처리 성능 검증, 멀티스레드 환경 안정성 테스트",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "C-ABI 공개 헤더 파일 설계 및 데이터 구조 정의",
            "description": "PublicCApi.h 헤더 파일을 설계하고 C-ABI 호환 데이터 구조 정의",
            "dependencies": [],
            "details": "C 스타일 구조체로 노트 시퀀스, 가사, 발음 기호, 피치 커브, 컨트롤 파라미터를 표현하는 데이터 타입 정의. extern \"C\" 링키지 지정으로 C++ 네임 맹글링 방지, 플랫폼별 ABI 호환성 고려하여 패킹과 정렬 설정. 에러 코드 열거형과 상태 코드 정의, 콜백 함수 포인터 타입 정의.",
            "status": "pending",
            "testStrategy": "C, C++에서 헤더 파일 포함 테스트, 구조체 크기 및 정렬 검증"
          },
          {
            "id": 2,
            "title": "핵심 API 함수 인터페이스 구현",
            "description": "초기화, 합성 요청, 리소스 해제 등 핵심 API 함수들 구현",
            "dependencies": [
              "9.1"
            ],
            "details": "voceversa_init(), voceversa_synthesize(), voceversa_cleanup() 등 핵심 함수 구현. 내부 C++ 객체와 C API 간 브리지 역할 수행, 예외 처리를 에러 코드로 변환. 스레드 안전성 보장을 위한 뮤텍스 적용, 글로벌 상태 관리 및 다중 인스턴스 지원.",
            "status": "pending",
            "testStrategy": "기본 합성 워크플로우 테스트, 메모리 누수 검사, 스레드 안전성 검증"
          },
          {
            "id": 3,
            "title": "비동기 처리 및 콜백 시스템 구현",
            "description": "비동기 합성 처리와 진행률 모니터링을 위한 콜백 시스템 구현",
            "dependencies": [
              "9.2"
            ],
            "details": "voceversa_synthesize_async() 함수로 백그라운드 스레드에서 합성 수행. 진행률 콜백 (progress_callback), 완료 콜백 (completion_callback), 에러 콜백 (error_callback) 지원. 작업 취소 기능 (voceversa_cancel_synthesis) 및 작업 상태 조회 API 구현.",
            "status": "pending",
            "testStrategy": "장시간 합성 작업에서 콜백 동작 확인, 작업 취소 기능 테스트, 메모리 관리 검증"
          },
          {
            "id": 4,
            "title": "동적 라이브러리 빌드 설정 및 심볼 익스포트",
            "description": "플랫폼별 동적 라이브러리 (.so, .dll, .dylib) 빌드 설정과 심볼 익스포트 구성",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3"
            ],
            "details": "CMakeLists.txt에 SHARED 라이브러리 타겟 추가, Windows에서 __declspec(dllexport) 매크로 정의, Linux/macOS에서 visibility 속성 설정. def 파일로 Windows DLL 심볼 명시적 익스포트, 버전 정보 및 메타데이터 임베딩. 정적 링킹 옵션도 함께 제공.",
            "status": "pending",
            "testStrategy": "각 플랫폼에서 동적 라이브러리 빌드 성공 확인, 심볼 익스포트 검증, 외부 프로그램에서 라이브러리 로딩 테스트"
          },
          {
            "id": 5,
            "title": "언어별 바인딩 예제 및 사용 가이드 작성",
            "description": "Python, JavaScript, C# 등 주요 언어에서 API 사용 예제와 바인딩 가이드 작성",
            "dependencies": [
              "9.4"
            ],
            "details": "Python ctypes 바인딩 예제, Node.js ffi-napi 바인딩, C# P/Invoke 선언 예제 작성. 각 언어별 래퍼 클래스 구현으로 사용 편의성 향상, 에러 처리 및 메모리 관리 패턴 제시. examples/ 디렉토리에 실행 가능한 샘플 코드 배치.",
            "status": "pending",
            "testStrategy": "각 언어에서 바인딩 코드 실행 테스트, 메모리 관리 정확성 검증, 다양한 플랫폼에서 바인딩 동작 확인"
          }
        ]
      },
      {
        "id": 10,
        "title": "GitHub Actions CI/CD 파이프라인 및 크로스플랫폼 빌드 자동화",
        "description": "GitHub Actions을 통한 지속적 통합/배포 파이프라인 구축 및 Windows, macOS, Ubuntu, Android, iOS 빌드 자동화",
        "details": "GitHub Actions 워크플로우 설정: 플랫폼별 빌드 매트릭스 (windows-latest, macos-latest, ubuntu-latest), 의존성 캐싱, 단위 테스트 자동 실행, 코드 커버리지 측정. Android NDK 빌드 설정, iOS Xcode 프로젝트 생성, 아티팩트 자동 업로드 및 버저닝. 코드 품질 검사 도구 (clang-format, cppcheck) 통합, 라이선스 준수 검증 스크립트.",
        "testStrategy": "각 플랫폼별 빌드 성공 확인, 배포된 바이너리 기능 테스트, CI 파이프라인 실행 시간 최적화 검증",
        "priority": "medium",
        "dependencies": [
          1,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 GitHub Actions 워크플로우 설정 및 크로스플랫폼 빌드 매트릭스 구성",
            "description": "GitHub Actions 워크플로우 파일을 생성하고 Windows, macOS, Ubuntu 플랫폼에 대한 빌드 매트릭스를 설정합니다.",
            "dependencies": [],
            "details": ".github/workflows/ci.yml 파일 생성. windows-latest, macos-latest, ubuntu-latest 매트릭스 설정. CMake 빌드 설정 및 컴파일러별 최적화 옵션 구성. 빌드 아티팩트 생성 및 업로드 설정. 병렬 빌드 최적화를 위한 cache 설정.",
            "status": "pending",
            "testStrategy": "각 플랫폼에서 워크플로우 실행 성공 확인, 빌드 아티팩트 생성 검증, 빌드 시간 측정"
          },
          {
            "id": 2,
            "title": "의존성 캐싱 및 단위 테스트 자동화 설정",
            "description": "빌드 시간 단축을 위한 의존성 캐싱과 CTest를 통한 자동화된 단위 테스트 실행을 구성합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "actions/cache를 사용한 CMake 빌드 캐시 및 패키지 관리자 캐시 설정. CTest 실행을 위한 워크플로우 단계 추가. 테스트 결과 리포팅을 위한 actions/upload-artifact 설정. 테스트 실패 시 로그 수집 및 알림 설정.",
            "status": "pending",
            "testStrategy": "캐시 적중률 확인, 테스트 실행 시간 측정, 테스트 결과 리포트 검증"
          },
          {
            "id": 3,
            "title": "코드 커버리지 측정 및 품질 검사 도구 통합",
            "description": "gcov/lcov를 통한 코드 커버리지 측정과 clang-format, cppcheck 등 코드 품질 검사 도구를 통합합니다.",
            "dependencies": [
              "10.2"
            ],
            "details": "gcov를 통한 커버리지 데이터 수집 설정. lcov를 사용한 HTML 커버리지 리포트 생성. clang-format을 통한 코드 스타일 검사. cppcheck를 통한 정적 분석. Codecov 또는 Coveralls 연동으로 커버리지 리포팅.",
            "status": "pending",
            "testStrategy": "커버리지 리포트 생성 확인, 코드 품질 검사 통과 여부 검증, 품질 메트릭 임계값 설정"
          },
          {
            "id": 4,
            "title": "Android NDK 및 iOS 빌드 설정",
            "description": "Android NDK를 통한 안드로이드 빌드와 Xcode를 통한 iOS 빌드 자동화를 설정합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "Android NDK 설치 및 CMake 툴체인 파일 설정. android.yml 워크플로우 생성으로 ARM64/x86_64 아키텍처 지원. iOS용 Xcode 프로젝트 생성을 위한 CMake 설정. macOS runner에서 iOS 시뮬레이터 및 디바이스 빌드 설정. 플랫폼별 서명 및 패키징 설정.",
            "status": "pending",
            "testStrategy": "안드로이드 APK 생성 확인, iOS 앱 빌드 성공 검증, 다양한 아키텍처별 바이너리 검증"
          },
          {
            "id": 5,
            "title": "자동 버저닝, 라이선스 검증 및 릴리스 배포 설정",
            "description": "시맨틱 버저닝을 통한 자동 태깅, 라이선스 준수 검증, GitHub Releases를 통한 자동 배포를 설정합니다.",
            "dependencies": [
              "10.3",
              "10.4"
            ],
            "details": "semantic-release 또는 GitVersion을 통한 자동 버전 관리. 라이선스 헤더 검증 스크립트 작성 및 CI 통합. GitHub Releases API를 통한 릴리스 노트 자동 생성. 플랫폼별 바이너리 및 라이브러리 패키징. 릴리스 브랜치 보호 규칙 및 승인 워크플로우 설정.",
            "status": "pending",
            "testStrategy": "버전 태깅 자동화 검증, 라이선스 규정 준수 확인, 릴리스 아티팩트 다운로드 및 실행 테스트"
          }
        ]
      },
      {
        "id": 11,
        "title": "UTAU 포맷 아티팩트 생성 및 호환성 검증",
        "description": "UTAU 포맷(f0.txt, sp.bin, ap.bin, meta.json)으로 분석/합성 아티팩트를 내보내고 world4utau와의 호환성을 검증하는 작업. WORLD ON/OFF 빌드와 테스트를 모두 통과하도록 품질 게이트를 설정합니다.",
        "details": "UTAU 포맷 메모:\n- f0.txt: 한 줄당 한 프레임 f0(Hz)\n- sp.bin/ap.bin: double 리틀엔디언, 길이 = frames*bins, 프레임 우선 row-major\n- meta.json: frames, bins, fftSize, framePeriodMs 등 합성에 필요한 메타 포함\n\n품질 게이트:\n- Build: PASS (WORLD ON/OFF)\n- Tests: PASS\n- 주요 경로 스모크: vv_world 분석/합성 경로 컴파일 완료\n\n다음 단계(옵션):\n- world4utau의 정확한 파일 배치/이름 규약 맞춤 옵션 추가\n- f0 추정 알고리즘 선택(Harvest/DIO) CLI 옵션화\n- sp/ap bin의 float/double 선택 저장 옵션\n- 멀티채널/스테레오 지원\n\nNote: 필요하면 world4utau와 100% 호환되는 경로/이름/데이터타입으로 스펙을 더 엄격히 맞추겠습니다.",
        "testStrategy": "- WORLD ON/OFF 모두 빌드 성공 확인\n- 단위/통합 테스트 전부 PASS\n- vv_world 경로의 분석→합성 파이프라인 컴파일/링크 스모크 체크",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "UTAU 아티팩트 내보내기 구현",
            "description": "f0.txt, sp.bin, ap.bin, meta.json 생성기와 저장 경로 정책 구현",
            "details": "파일 사양에 맞춘 내보내기 구현:\n- f0.txt: 프레임당 f0(Hz) 텍스트, 줄바꿈 LF, NaN은 0 또는 sentinel 처리 정책 정의\n- sp.bin/ap.bin: little-endian double, shape = frames*bins(행우선)\n- meta.json: frames, bins, fftSize, framePeriodMs, sampleRate 등 포함\n- 경로: 출력 디렉토리/파일명 규약, 덮어쓰기/유니크 네이밍 정책\n- 옵션: float 저장 지원(호환 모드) 및 정밀도 주의사항 문서화",
            "testStrategy": "골든: 소규모 샘플에 대해 참조 아티팩트와 바이트 비교/허용오차 비교\n상호운용: world4utau가 읽을 수 있는지 수동/자동 검증, 역파싱해 round-trip 확인",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 2,
            "title": "world4utau 상호운용 테스트",
            "description": "world4utau와 상호 교차 로딩 테스트 케이스 추가 및 호환성 체크리스트",
            "details": "테스트 하네스에서 world4utau를 호출하여 상호 운용성을 검증합니다.\n- 입력: 당사 생성 f0/sp/ap/meta → world4utau 합성\n- 출력: 오디오/중간 산출물 비교 및 실패 시 진단 로그 저장\n- 스크립트: 재현 가능한 셸/파워셸 스크립트 제공",
            "testStrategy": "교차: world4utau 산출물과 우리 합성물의 스펙/품질 비교(스펙트럼/LSD)\n회귀: CI에서 주기적으로 실행하여 호환성 퇴행 감지",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 3,
            "title": "WORLD ON/OFF 빌드 품질 게이트",
            "description": "WORLD 경로 온/오프 모두 테스트 통과 확인 및 실패 시 차단하는 CI 품질 게이트",
            "details": "CMake 옵션 VOCEVERSA_WITH_WORLD=ON/OFF 매트릭스를 CI에 추가하고, 두 구성 모두 컴파일/테스트 통과를 강제합니다. 실패 시 PR 차단. 산출물 크기/의존성도 점검합니다.",
            "testStrategy": "CI: GitHub Actions에서 두 구성 매트릭스 실행, 테스트/스모크 실패 시 실패 처리\n리포트: 빌드 로그와 산출물 메타데이터 업로드",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          }
        ]
      },
      {
        "id": 12,
        "title": "TuneLab 통합을 위한 Voceversa 확장(.tlx) 구현",
        "description": "Voceversa C++ 엔진을 TuneLab에 통합하는 확장(.tlx)을 개발합니다. WORLD, PSOLA, ONNX 백엔드를 지원하고 실시간 친화 설정을 제공합니다.",
        "status": "pending",
        "dependencies": [
          9
        ],
        "priority": "high",
        "details": "1.  **Extension API Adapter Development:** Create the necessary C++ code to interface with TuneLab's extension API, understanding its plugin architecture for loading external libraries and exposing functionalities.\n2.  **C-ABI Integration:** Utilize the public C-ABI (from Task 9) to load and interact with the voceversa C++ engine, ensuring proper function calls, data marshalling, and error handling across the C-ABI boundary.\n3.  **Backend Exposure:** Expose the synthesis capabilities of voceversa for WORLD, PSOLA, and ONNX backends by mapping TuneLab's synthesis requests to the appropriate voceversa functions and managing their lifecycle.\n4.  **Realtime-Friendly Settings:** Design the integration to support realtime audio processing, optimizing buffer sizes, minimizing latency, and providing configurable parameters within the extension for performance/quality balance.\n5.  **Packaging (.tlx):** Implement the necessary steps to package the compiled C++ code (dynamic library) and any required assets or configuration files into the .tlx format according to TuneLab's specification.\n6.  **Cross-Platform Support:** Ensure the extension compiles and functions correctly on Windows, macOS, and Linux, handling platform-specific build configurations and library loading.\n7.  **Minimal UI Wiring:** Identify and implement the minimal necessary UI elements within TuneLab to control the voceversa extension, such as exposing parameters, selecting synthesis backends, and triggering operations.\n8.  **Demo Project Import/Export Verification:** Create and verify sample TuneLab projects that utilize the voceversa extension, testing the ability to import projects and export projects that correctly embed or reference the extension's settings and data.",
        "testStrategy": "1.  **Automated Smoke Tests:** Develop automated tests to verify basic functionality, including extension loading, voceversa engine initialization, and simple synthesis operations for each backend (WORLD, PSOLA, ONNX).\n2.  **Functional Testing:** Verify that all exposed synthesis backends produce audible output. Test various realtime-friendly settings (e.g., buffer sizes, quality presets) and observe their impact on performance and audio quality. Confirm cross-platform functionality on Windows, macOS, and Linux. Test UI controls within TuneLab for correct interaction.\n3.  **Integration Testing:** Verify seamless integration with TuneLab's project import/export functionality using sample projects. Ensure projects created with the extension can be opened and played back correctly.\n4.  **Documentation Verification:** Review the generated installation and usage documentation for clarity, accuracy, and completeness.\n5.  **Performance Testing:** Conduct basic performance tests to ensure the realtime-friendly settings achieve desired latency and CPU usage targets.",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "voceversa vs 기존 파이프라인 벤치마킹·포지셔닝 스위트 구축",
        "description": "OpenUtau+WORLDLINE-R, ENUNU/NNSVS, TuneLab 엔진 등과 비교하여 voceversa의 성능을 정량·정성적으로 평가하는 종합 벤치마크 스위트를 개발합니다.",
        "status": "pending",
        "dependencies": [
          7,
          10,
          12
        ],
        "priority": "high",
        "details": "The benchmarking suite will be implemented under `tools/bench`.\n1.  **Golden Dataset Creation**: Curate a diverse golden dataset of phrases and styles (e.g., spoken, sung, different emotions, languages if applicable). This dataset should be representative of real-world use cases and include challenging cases for pitch-shift and alignment. Define clear recording/annotation standards for the dataset.\n2.  **Integration Points**:\n    *   **Voceversa**: Integrate voceversa via the OpenUtau resampler adapter (leveraging Task 7) and the TuneLab .tlx extension (leveraging Task 12). This will allow benchmarking voceversa in contexts relevant to its target integrations.\n    *   **OpenUtau+WORLDLINE-R**: Set up a reference OpenUtau environment with WORLDLINE-R for comparison.\n    *   **ENUNU/NNSVS**: Configure ENUNU/NNSVS with reference models for benchmarking.\n    *   **TuneLab Engines**: Utilize TuneLab's native engines for comparison, potentially requiring specific setup or API calls.\n3.  **Metric Implementation**:\n    *   **Latency**: Develop scripts to measure end-to-end and streaming latency for each pipeline. This involves precise timing of input to output.\n    *   **CPU/GPU Usage**: Implement monitoring tools to capture CPU and GPU utilization during synthesis for each pipeline.\n    *   **MOS-lite (ABX/MUSHRA)**: Design and prepare for subjective listening tests. This involves generating A/B audio pairs or MUSHRA-style samples. The actual human evaluation will be a separate activity, but the suite should generate the necessary audio artifacts.\n    *   **STFT/LSD (Log-Spectral Distance)**: Implement objective metrics for spectral similarity.\n    *   **Pitch-shift Formant Preservation**: Develop methods to quantify how well formants are preserved during pitch shifting operations. This might involve analyzing spectrograms or specific formant tracking algorithms.\n    *   **Alignment Robustness**: Design tests to assess how well each system handles misalignments or challenging input conditions (e.g., noisy input, unusual phrasing).\n4.  **Reproducible Scripts**: All benchmarking procedures must be fully scripted and reproducible, allowing for consistent re-evaluation. Scripts should manage environment setup, data processing, execution of synthesis, and metric calculation.\n5.  **Artifact Generation**: Automate the generation of result tables and plots for all measured metrics. Automate the generation of A/B audio samples for subjective evaluation.\n6.  **CI Integration**: Configure a nightly CI job (leveraging Task 10) that runs a subset of the benchmarks to detect performance regressions early.\n7.  **Report Generation**: Prepare a detailed report in `docs/benchmarks` summarizing the findings, including result tables, plots, and a README section outlining claims and caveats of the benchmark.",
        "testStrategy": "1.  **Script Validation**: Verify that all benchmarking scripts run without errors across all target pipelines and produce expected output formats (e.g., CSV, JSON, audio files).\n2.  **Reproducibility Check**: Run the full benchmark suite multiple times on the same environment to ensure consistent results within an acceptable margin of error.\n3.  **Metric Sanity Check**: Manually inspect a subset of generated metrics (e.g., listen to A/B audio, visually inspect spectrograms for STFT/LSD, check CPU/GPU logs) to ensure they are plausible and correctly calculated.\n4.  **Integration Verification**: Confirm that voceversa is correctly invoked via the OpenUtau adapter and TuneLab extension, and that external pipelines (ENUNU, WORLDLINE-R) are correctly integrated and producing output.\n5.  **CI Job Execution**: Verify that the nightly CI job successfully triggers, completes, and publishes the benchmark results or flags regressions.\n6.  **Report Review**: Conduct a thorough review of the `docs/benchmarks` report for accuracy, clarity, completeness, and adherence to the specified artifacts (tables, plots, claims, caveats). Ensure all claims are supported by data.",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "영속 리샘플러 서버와 경량 러너 구현",
        "description": "저지연 IPC(HTTP/gRPC/UDS)를 사용하는 영속 리샘플러 서버와 OpenUtau/클래식 UTAU용 경량 러너를 개발하여 엔진을 상시 가열 상태로 유지하고 첫 렌더 지연을 최소화합니다.",
        "status": "pending",
        "dependencies": [
          7,
          9
        ],
        "priority": "high",
        "details": "This task involves creating a server application that hosts the voceversa resampler engine in a persistent mode. The server should support low-latency Inter-Process Communication (IPC) mechanisms, specifically HTTP, gRPC, and Unix Domain Sockets (UDS), to handle batched and streaming synthesis requests. Key goals include keeping the engine hot by preloading models and managing thread pools, and minimizing the first-render latency for synthesis requests.\n\nDeliverables for this task include:\n1.  `voceversa-server` binary: The main server application.\n2.  OpenUtau Runner: A lightweight client application or library compatible with OpenUtau's resampler interface.\n3.  UTAU Tool2-compatible CLI shim: A command-line interface shim that mimics the behavior of `resampler.exe` and `wavtool.exe` for classic UTAU, communicating with the server.\n4.  Protocol documentation: Comprehensive documentation for the chosen IPC protocols and data formats.\n5.  Smoke tests: Basic tests to verify the server and runner functionality.\n\nThe implementation must be cross-platform (Windows, macOS, Linux). A fallback mechanism to a single-shot CLI mode should be provided if the server is unavailable or not running.",
        "testStrategy": "1.  **Server Functionality Tests:** Verify server startup, graceful shutdown, and persistent operation. Test concurrent connections and request handling.\n2.  **IPC Protocol Verification:** Develop automated tests for each IPC mechanism (HTTP, gRPC, UDS) to ensure correct data serialization/deserialization, request/response handling, and error reporting. Measure latency for various request sizes.\n3.  **Runner Compatibility Tests:**\n    *   **OpenUtau Runner:** Integrate the runner with OpenUtau and perform synthesis tests using various voicebanks and settings. Compare output quality and performance against direct engine calls.\n    *   **UTAU CLI Shim:** Test the CLI shim with classic UTAU projects, ensuring it correctly processes command-line arguments and produces expected output files. Verify compatibility with `resampler.exe` and `wavtool.exe` specifications.\n4.  **Performance Benchmarking:** Measure first-render latency, throughput for batched requests, and resource utilization (CPU, memory) under load. Compare performance with single-shot CLI mode.\n5.  **Cross-Platform Testing:** Deploy and test the server and runners on Windows, macOS, and Linux environments to ensure full compatibility and consistent behavior.\n6.  **Fallback Mechanism Test:** Verify that the runners correctly fall back to single-shot CLI mode when the server is not running or unreachable.\n7.  **Documentation Review:** Review the protocol documentation for clarity, completeness, and accuracy against the implemented protocols.",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Voceversa 백엔드용 UTAU 플래그 및 피치 커브 매핑",
        "description": "UtauAdapter 내에서 UTAU 호환 플래그와 피치 커브 매핑 로직을 설계·구현합니다. WORLD, PSOLA, ONNX 백엔드를 지원하며 기본값과 오버라이드를 구성 가능하게 합니다.",
        "status": "pending",
        "dependencies": [
          7,
          3,
          5
        ],
        "priority": "high",
        "details": "This task involves extending the UtauAdapter to fully interpret and translate UTAU project parameters into the internal data structures required by voceversa's synthesis backends. Key implementation steps include:\n- **UTAU Parameter Parsing:** Implement robust parsing for UTAU-specific parameters such as velocity, modulation, gender (formant shift), vibrato, and other note-level flags from `.ust` files or command-line inputs.\n- **Base64 RLE Pitch String Decoding:** Develop a decoder for the Base64 Run-Length Encoded pitch strings found in UTAU's `_pitch.txt` format, converting them into a usable pitch curve representation.\n- **Curve-to-Parameter Mapping:** Design and implement a flexible system to map UTAU's continuous curves (pitch, volume, vibrato depth/rate) to the discrete or continuous parameters expected by the WORLD, PSOLA, and ONNX synthesis backends. This includes handling interpolation and smoothing.\n- **Formant-Preserving Pitch/Time Scaling:** Integrate controls for formant-preserving pitch shifting and time scaling, ensuring these transformations are correctly applied through the selected synthesis backend while maintaining naturalness.\n- **Default Values and Overrides:** Define a set of safe default values for all mapped parameters. Implement a mechanism for per-backend overrides, allowing specific synthesis engines (WORLD, PSOLA, ONNX) to have their own custom mapping rules or parameter ranges.\n- **Output:** Produce a detailed specification document outlining the mapping logic, parameter ranges, default behaviors, and override mechanisms. The implementation will be integrated into the `UtauAdapter` component.",
        "testStrategy": "- **Unit Tests:**\n    - Develop unit tests for the Base64 RLE pitch string decoder, covering various valid and edge-case encoded strings.\n    - Create unit tests for parsing UTAU flags and note properties, ensuring correct extraction of velocity, modulation, and other parameters.\n    - Test the curve-to-parameter mapping logic in isolation, verifying that UTAU curves are accurately transformed into backend-compatible parameter sequences (e.g., F0 contours, gain envelopes).\n- **Integration Tests:**\n    - Prepare a comprehensive suite of sample `.ust` cases that exercise all supported UTAU flags, pitch curves, and scaling parameters.\n    - Run these `.ust` cases through the `UtauAdapter` and verify that the generated internal parameters for WORLD, PSOLA, and ONNX backends are correct and consistent with the UTAU input.\n    - Perform end-to-end synthesis tests using the mapped parameters for each backend (WORLD, PSOLA, ONNX) and compare the synthesized audio output against reference outputs from traditional UTAU resamplers (e.g., world4utau) for quality, accuracy, and adherence to UTAU's intended sound.\n    - Verify that per-backend overrides correctly alter the mapping behavior as specified.\n- **Regression Tests:** Ensure that the new mapping logic does not negatively impact existing `UtauAdapter` functionalities or break compatibility with basic UTAU project structures.\n- **Documentation Review:** Validate that the generated specification document accurately reflects the implemented mapping logic and serves as a clear reference for future development and maintenance.",
        "subtasks": [
          {
            "id": 1,
            "title": "백엔드별 플래그 스키마/기본값 정의",
            "description": "WORLD/PSOLA/ONNX 백엔드별 지원 플래그 목록, 타입, 범위, 기본값 정의",
            "status": "pending",
            "dependencies": [],
            "details": "플래그 스키마를 선언적(JSON/YAML)으로 정의합니다.\n- 공통: velocity, modulation, gender(formant), flags, offset/length\n- WORLD/PSOLA/ONNX별 지원 여부/범위/기본값/매핑키 지정\n- 문서: docs/flag-schema.md에 표와 예시 구성",
            "testStrategy": "스키마 검증: JSON Schema로 정적 검증, 예시 파일 로드 테스트\n호환: 미지원 플래그 시 경고/대체전략 적용 여부 확인"
          },
          {
            "id": 2,
            "title": "피치 커브 매핑 구현",
            "description": "UTAU pitchbend 커브를 내부 타임라인/프레임 해상도로 변환하는 보간/양자화 로직 구현",
            "status": "pending",
            "dependencies": [],
            "details": "Base64 RLE `_pitch.txt` 디코더 → 시간축 샘플로 복원 → 프레임 해상도(홉)로 보간/양자화.\n- 보간: 선형/스플라인 선택, 외삽/경계 처리\n- 정합: note/expressions와의 정렬 보장, 샘플레이트 변화 대응",
            "testStrategy": "단위: 인조 커브(계단/사인) 디코딩/보간 정확도 측정\n통합: UST 샘플 세트로 매핑 후 F0 컨투어 RMSE 검증"
          },
          {
            "id": 3,
            "title": "호환성 테스트(UST/Expressions)",
            "description": "샘플 UST/표현식 셋으로 매핑 로직 회귀 테스트 작성",
            "status": "pending",
            "dependencies": [],
            "details": "샘플 UST/표현식 조합(플래그/피치/길이) 세트를 만들고, 백엔드별 내부 파라미터가 기대 규칙을 따르는지 검증하는 회귀 테스트를 작성합니다.",
            "testStrategy": "스냅샷: 내부 파라미터(JSON) 스냅샷 비교, 의도된 변경 외 차이 탐지\nE2E: 간단 합성으로 청감/피치 일치성 점검"
          }
        ]
      },
      {
        "id": 16,
        "title": "반복 렌더를 위한 워姆스타트 및 캐싱 레이어",
        "description": "보이스뱅크 특징, ONNX 모델, 피치마크, 세그먼트 재사용 등을 위한 캐싱 서브시스템을 구현하고 결정적 무효화 규칙으로 불필요한 I/O와 연산을 줄입니다.",
        "status": "pending",
        "dependencies": [
          11,
          12,
          14,
          15
        ],
        "priority": "medium",
        "details": "Develop a multi-layered caching system to optimize performance for repetitive synthesis operations. This includes:\n1.  **Voicebank Feature Cache:** Store pre-analyzed frequency (frq), spectral envelope (sp), and aperiodicity (ap) data for voicebank segments. This cache should be indexed by voicebank ID, segment identifier, and any relevant analysis parameters.\n2.  **ONNX Model/Session Pool:** Maintain a pool of loaded ONNX models and inference sessions to avoid repeated loading and initialization overhead. Implement a mechanism to manage session lifecycle and resource cleanup.\n3.  **PSOLA Pitchmark Cache:** Cache computed pitchmarks for PSOLA synthesis, indexed by input pitch curve, duration, and other relevant PSOLA parameters.\n4.  **Segment-Level Reuse:** Explore and implement mechanisms for reusing entire synthesized audio segments if inputs (e.g., text, flags, pitch curve) are identical.\nThe caching system must support deterministic cache invalidation based on changes in input parameters, UTAU flags, and the hash of the underlying synthesis model (e.g., ONNX model hash). Implement configurable toggles to enable/disable specific cache layers or the entire subsystem. Design and integrate metrics hooks to monitor cache hit/miss rates, size, and performance impact.",
        "testStrategy": "1.  **Unit Tests:**\n    *   Develop comprehensive unit tests for each cache component (voicebank feature cache, ONNX pool, pitchmark cache) to verify correct storage, retrieval, and eviction logic.\n    *   Test cache invalidation mechanisms rigorously, ensuring that changes in inputs, flags, or model hashes correctly trigger invalidation and re-computation.\n    *   Verify the functionality of cache toggles (enable/disable) and their impact on cache behavior.\n2.  **Integration Tests:**\n    *   Integrate the caching subsystem with the synthesis pipeline (e.g., via the persistent resampler server from Task 14 or TuneLab extension from Task 12) and run synthesis tasks with repetitive inputs to confirm performance improvements and correctness.\n    *   Verify that cached data is correctly used across multiple synthesis requests.\n3.  **Performance & Metrics Tests:**\n    *   Utilize the benchmarking suite (Task 13) to measure the reduction in I/O and compute time with the caching layer enabled versus disabled.\n    *   Verify that metrics hooks correctly report cache hit/miss rates, cache size, and other relevant performance indicators.\n4.  **Concurrency Tests:**\n    *   Test the caching system under concurrent access scenarios to ensure thread-safety and data integrity.",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "OpenUtau 통합 패키지",
        "description": "Resampler Manifest(YAML), 샘플 플래그/표현식 맵핑, 최소 샘플 프로젝트, CI 스냅샷 테스트 등으로 버전 간 출력 검증을 포함한 일류 OpenUtau 통합을 제공합니다.",
        "status": "pending",
        "dependencies": [
          7,
          14,
          15
        ],
        "priority": "high",
        "details": "This task involves creating all necessary components for seamless integration of voceversa with OpenUtau.\n1.  **Resampler Manifest (YAML):** Define the structure and content of the `resampler.yaml` file required by OpenUtau. This manifest should declare voceversa's capabilities, supported sample rates, bit depths, and any specific parameters it can handle. It should also specify the command-line interface for invoking the voceversa resampler, ideally pointing to the persistent resampler server.\n2.  **Sample Flags/Expressions Mapping:** Map OpenUtau's internal note properties and expressions (e.g., velocity, modulation, gender, vibrato, flags) to voceversa's internal parameters. Leverage the `UtauAdapter` (Task 7, 15) to ensure correct translation. Document this mapping clearly.\n3.  **Minimal Sample Project:** Create a small, self-contained OpenUtau project (`.ust` file, voicebank, `resampler.yaml`) that demonstrates basic voceversa functionality. This project should serve as a quick-start guide and a reference for users. Include a simple melody with a few common UTAU flags to showcase the mapping.\n4.  **CI Snapshot Tests:** Develop automated tests that use the minimal sample project to render audio with voceversa. Capture \"golden\" audio outputs (snapshots) for specific OpenUtau/voceversa versions. Implement a comparison mechanism (e.g., perceptual audio difference, waveform comparison, feature comparison like pitch/formant contours) to detect regressions or unexpected changes in output across future builds or OpenUtau versions. Integrate these tests into the CI/CD pipeline.",
        "testStrategy": "1.  **Manifest Validation:** Use OpenUtau's internal manifest parser (if available, or simulate its behavior) to validate the `resampler.yaml` for correctness and adherence to OpenUtau's specification. Verify that all declared parameters are correctly recognized.\n2.  **Flags/Expressions Mapping Tests:** Create unit tests within the `UtauAdapter` (or a dedicated mapping module) to ensure that various OpenUtau flags and expressions are correctly translated into voceversa's internal parameters. Test edge cases and combinations of flags.\n3.  **Sample Project Functionality:** Manually load the minimal sample project in OpenUtau and verify that voceversa is recognized as a resampler. Render the project and visually/auditorily inspect the output for correctness and quality.\n4.  **CI Snapshot Test Automation:** Run the automated snapshot tests in a CI environment. Verify that the tests correctly compare current outputs against golden snapshots. Introduce intentional changes to voceversa's output (e.g., a minor bug fix affecting pitch) and ensure the snapshot tests fail as expected. Test the process of updating golden snapshots when changes are intentional.",
        "subtasks": [
          {
            "id": 1,
            "title": "Resampler Manifest (YAML) 초안 작성",
            "description": "OpenUtau용 리샘플러 매니페스트 작성: 지원 인자 정의, 기본값/범위, 표현식 매핑 키 예약어 포함. 안전 기본값과 버전 필드 포함.",
            "status": "pending",
            "dependencies": [],
            "details": "resampler.yaml에 name, version, args, defaults, ranges, presets, cliTemplate 필드 정의.\n- 경로/인용 규칙(Windows/Unix)과 환경 변수 치환 규칙 문서화\n- 파일 위치와 배포 패키지 포함 방법 정의",
            "testStrategy": "정적: 스키마/링터로 YAML 검증\n동적: OpenUtau(또는 모사기)로 로드 테스트 및 파라미터 인식 확인"
          },
          {
            "id": 2,
            "title": "플래그/표현식 하위셋 맵핑 표 초안",
            "description": "moresampler/straycat 주요 플래그를 voceversa 백엔드 옵션에 매핑. 미지원 항목 표시 및 안전 대안 제시.",
            "status": "pending",
            "dependencies": [],
            "details": "docs/openutau_mapping.md에 표로 정리: 플래그명/타입/범위/기본값/백엔드별 처리.\n- 미지원 항목은 경고/무시/대체 전략을 병기",
            "testStrategy": "문서 일치성: 구현된 매핑과 표의 자동 교차검증 스크립트\n샘플 UST로 플래그 인식/경고 발생 여부 테스트"
          },
          {
            "id": 3,
            "title": "샘플 프로젝트 + 스냅샷 테스트",
            "description": "OpenUtau 샘플 프로젝트 구성, 고정 입력/출력 경로와 리렌더 스냅샷 비교 테스트 작성(CI에서 OS별 해시 비교).",
            "status": "pending",
            "dependencies": [],
            "details": "minimal OU 프로젝트(짧은 멜로디, 기본 플래그)와 스크립트를 저장하고, 렌더 결과를 golden으로 보관하여 스냅샷 비교를 자동화합니다. OS별 라인엔딩/부동소수점 차이는 허용 오차로 처리.",
            "testStrategy": "스냅샷: 오디오/피치/메트릭 비교(PESQ/STFT-LSD/해시)\nCI: 변경 시 자동 실행 및 차이 리포트 업로드"
          }
        ]
      },
      {
        "id": 18,
        "title": "voceversa 및 경쟁 엔진 종합 벤치마킹 스위트 확장",
        "description": "기존 벤치마킹 스위트를 moresampler와 world4utau, ENUNU/NNSVS, TuneLab까지 포함하도록 확장하고, 재현 가능한 렌더 시간, CPU/메모리 사용량, 객관적 품질 지표에 중점을 둡니다.",
        "status": "pending",
        "dependencies": [
          7,
          11,
          12,
          13,
          14,
          15,
          17
        ],
        "priority": "high",
        "details": "The task involves extending the benchmarking framework established in Task 13 to cover a broader range of speech synthesis engines. This includes:\n1.  **Integration of New Engines**:\n    *   **moresampler**: Research and implement integration points for `moresampler`. This likely involves command-line execution and parsing its output or interacting with its API.\n    *   **world4utau**: Leverage existing UTAU compatibility work (Task 7, 11) to integrate `world4utau` into the suite. This will involve setting up `world4utau` as a comparable resampler/engine.\n    *   **ENUNU/NNSVS**: Ensure robust integration and configuration for `ENUNU/NNSVS` as a benchmark target, including necessary environment setups and model loading.\n    *   **TuneLab Engines**: Utilize the TuneLab extension (Task 12) to benchmark `voceversa` within the TuneLab environment and compare against native TuneLab synthesis.\n2.  **Metric Collection**:\n    *   **Render-time**: Implement precise timing mechanisms for each engine's synthesis process, from input to output. Account for warm-up times and caching effects.\n    *   **CPU/Memory Usage**: Integrate system monitoring tools (e.g., `psutil` for Python, platform-specific tools for C++) to capture peak and average CPU utilization and memory footprint during synthesis for each engine.\n    *   **Quality Proxies**: Implement calculation of objective audio quality metrics such as PESQ (Perceptual Evaluation of Speech Quality), STOI (Short-Time Objective Intelligibility), or other SNR-like measures. This requires a 'golden dataset' (from Task 13) with reference audio. Develop methods to compare synthesized pitch contours and timing against reference data, potentially using dynamic time warping (DTW) or similar algorithms.\n3.  **Reproducibility and Documentation**:\n    *   Ensure the entire benchmarking process is fully scriptable and reproducible across different environments and operating systems.\n    *   Document the setup process for each engine, the methodology for metric collection, and the interpretation of results in a comprehensive README or dedicated documentation.\n    *   Provide clear instructions for running the suite and analyzing the output.\n4.  **Output and Reporting**:\n    *   Standardize output formats (e.g., CSV, JSON) for all collected metrics, ensuring easy parsing and analysis.\n    *   Develop basic reporting scripts to generate comparative charts and summaries, highlighting performance differences and quality trends.",
        "testStrategy": "1.  **Engine Integration Validation**: For each target engine (moresampler, world44utau, ENUNU/NNSVS, TuneLab), run a small set of test cases to confirm successful integration, correct execution, and valid audio output. Verify that all necessary configurations and dependencies for each engine are correctly handled.\n2.  **Metric Accuracy Verification**:\n    *   **Render-time**: Manually time a few synthesis operations for each engine and compare against automated measurements to ensure accuracy and consistency across multiple runs.\n    *   **CPU/Memory**: Monitor system resources during benchmark runs using external tools (e.g., Task Manager, `htop`, `top`) and compare against reported metrics for consistency and plausibility.\n    *   **Quality Proxies**: For a subset of the golden dataset, manually inspect synthesized audio and compare it against reference audio, cross-referencing with calculated objective scores to ensure they align with perceptual quality and expected behavior.\n3.  **Reproducibility Testing**: Execute the full benchmark suite multiple times on the same hardware and software configuration to verify consistent results for all metrics (render-time, CPU/memory, quality proxies). Document any observed variances and their acceptable thresholds.\n4.  **Documentation Review**: Have an independent team member review the documentation for clarity, completeness, and accuracy, ensuring all setup and execution steps are easily understandable and executable by someone unfamiliar with the project.\n5.  **Edge Case Testing**: Include challenging cases from the golden dataset (e.g., extreme pitch shifts, complex phoneme sequences, long phrases, very short notes) to stress-test each engine and the metric collection system, identifying potential failure points or performance bottlenecks.",
        "subtasks": [
          {
            "id": 1,
            "title": "입력 코퍼스/시나리오 선정 및 고정화",
            "description": "공개 사용 가능한 샘플 셋 수집, 라이선스 확인, 고정 파라미터 정의",
            "status": "pending",
            "dependencies": [],
            "details": "공개 라이선스 코퍼스(예: CMU Arctic 등)와 자체 샘플을 선정합니다. 샘플레이트/비트뎁스/길이/피치 변조 시나리오를 고정하며, 재현 가능한 랜덤 시드와 메타데이터(라이선스/출처)를 포함합니다.",
            "testStrategy": "재현성: 동일 환경에서 재실행 시 메트릭 분산이 허용 범위 내인지 검증\n라이선스: 라이선스 체크리스트 자동 점검"
          },
          {
            "id": 2,
            "title": "벤치마크 러너/스크립트 작성",
            "description": "각 엔진 호출 스크립트, 타임/CPU/메모리 계측, 결과 수집 포맷 설계",
            "status": "pending",
            "dependencies": [],
            "details": "tools/bench에 공통 인터페이스의 러너를 구현합니다.\n- 시간: /usr/bin/time 또는 고해상도 타이머\n- 자원: psutil(또는 플랫폼별)로 CPU/메모리 수집\n- 출력: CSV/JSON 통일 포맷, 실패 시 리트라이/로그 수집",
            "testStrategy": "드라이런: 더미 엔진으로 파이프라인이 끝까지 실행되는지 확인\n계측: 수동 타이밍과 자동 측정값 일치 여부 샘플 검증"
          },
          {
            "id": 3,
            "title": "리포트 생성 및 문서화",
            "description": "표/그래프 자동 생성, 결과 해석 및 위치 선정 메시지 제안",
            "status": "pending",
            "dependencies": [],
            "details": "Python(matplotlib/pandas)으로 결과 집계 및 시각화 스크립트 작성, docs/benchmarks에 리포트 생성. 재현 가능한 빌드 파이프라인으로 그래프/표를 갱신합니다.",
            "testStrategy": "재현성: 동일 입력에 동일 그래프 생성 확인\n정합성: 원시 메트릭과 리포트 수치의 무작위 샘플 교차검증"
          }
        ]
      },
      {
        "id": 19,
        "title": "호환성 안전장치 및 합성 후 필터",
        "description": "견고한 플래그 맵핑 테이블과 회귀 스냅샷 테스트 등 호환성 안전장치를 구현하고, 포먼트 시프트와 무성/유성 비율 조정을 위한 선택적 합성 후 필터를 모듈형으로 개발합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          5,
          7,
          15,
          17
        ],
        "priority": "medium",
        "details": "This task focuses on enhancing the robustness and flexibility of the synthesis pipeline. \n\n1.  **Compatibility Safeguards Implementation:**\n    *   **Flag Mapping Tables Refinement:** Build upon the existing UTAU flag parsing (Task 15) and OpenUtau integration (Task 17) to create comprehensive, configurable flag mapping tables. These tables will ensure that all relevant UTAU flags (e.g., gender, modulation, velocity, start/end offsets) are correctly interpreted and translated into internal synthesis parameters for all supported backends (WORLD, PSOLA, ONNX). Consider a declarative format (e.g., JSON, YAML) for these mappings to allow for easy updates and extensions.\n    *   **Regression Snapshot Testing Framework:** Develop an automated system for generating and comparing synthesis output snapshots. This system should:\n        *   Capture key synthesis artifacts (e.g., generated audio WAV, extracted F0, spectral parameters, internal data packets) for a predefined set of test cases.\n        *   Store these as baseline 'snapshots'.\n        *   Implement a comparison mechanism (e.g., audio diff, numerical comparison of parameter arrays with tolerance) to detect regressions when code changes are introduced.\n        *   Integrate this into the CI/CD pipeline (leveraging Task 17's CI snapshot tests) to run automatically on pull requests or commits.\n\n2.  **Optional Post-Synthesis Filters Development:**\n    *   **Modular Design:** Implement each post-filter as a separate, pluggable module, ideally conforming to the `ISynthesisNode` interface (Task 2) or a similar processing node abstraction. This allows them to be chained or applied selectively.\n    *   **Formant Shift Module:** Develop a module that can apply a formant shift to the synthesized audio. This should allow for adjustable shift amounts (e.g., in semitones or Hz) and potentially different algorithms (e.g., simple spectral scaling, more advanced vocoder-based methods).\n    *   **Unvoiced/Voiced Adjustments Module:** Create a module to manipulate the unvoiced/voiced characteristics of the synthesized speech. This could include:\n        *   Adjusting the balance between voiced and unvoiced components.\n        *   Modifying the aperiodicity (noise) levels in voiced segments.\n        *   Allowing for global or time-varying adjustments.\n    *   **Integration Points:** Ensure these post-filters can be easily inserted into the synthesis pipeline after the core synthesis backends (Task 3, 5, 6) but before final audio output.\n\nConsiderations:\n*   Performance impact of post-filters, especially for real-time applications.\n*   User-configurable parameters for each filter.\n*   Error handling and robust parameter validation for all new components.",
        "testStrategy": "1.  **Unit Tests:**\n    *   Develop comprehensive unit tests for the flag mapping logic, covering various UTAU flag combinations, edge cases, and invalid inputs to ensure correct parameter translation.\n    *   Create unit tests for each post-filter module (formant shift, unvoiced/voiced adjustments) to verify their specific transformations on synthetic or pre-recorded audio segments.\n\n2.  **Integration Tests (Regression Snapshot System):**\n    *   Define a diverse set of test cases covering different voicebanks, UTAU flags, pitch curves, and synthesis backends (WORLD, PSOLA, ONNX).\n    *   Implement automated snapshot generation for these test cases, capturing audio and key internal parameters.\n    *   Develop a robust comparison algorithm for snapshots, including configurable tolerances for numerical differences and perceptual metrics for audio.\n    *   Integrate the snapshot tests into the CI/CD pipeline to automatically detect regressions on every code change.\n    *   Verify that the snapshot system correctly identifies intentional changes versus unintended regressions.\n\n3.  **Functional Testing (Post-Filters):**\n    *   Apply each post-filter to synthesized audio from various backends and verify the expected sonic changes through spectral analysis, waveform inspection, and subjective listening tests.\n    *   Test the chaining of multiple post-filters to ensure they interact correctly.\n    *   Verify that the post-filters can be enabled/disabled and configured via their respective parameters.\n\n4.  **Performance Testing:**\n    *   Measure the latency and CPU overhead introduced by the post-filters to ensure they meet real-time performance requirements, especially when chained.",
        "subtasks": [
          {
            "id": 1,
            "title": "플래그 맵핑 테이블/호환 매트릭스 문서화",
            "description": "moresampler/straycat 대비 지원/미지원 항목, 대체 전략, 경고 메시지 정책 포함",
            "status": "pending",
            "dependencies": [],
            "details": "docs/compat-matrix.md에 백엔드별 지원 여부/제한/대체전략을 표로 문서화하고, 런타임 경고 정책과 예시를 포함합니다. JSON 매핑 설정과 동기화 스크립트를 제공합니다.",
            "testStrategy": "문서-구현 싱크: 매핑 JSON을 로드해 어댑터에 적용하고 문서 표와 자동 대조\n정적: JSON Schema/링트로 구문 오류 방지"
          },
          {
            "id": 2,
            "title": "회귀 스냅샷 테스트 워크플로우",
            "description": "호스트별(OU/CLI) 고정 입력에 대한 출력 해시/메트릭 회귀 파이프라인 GitHub Actions에 추가",
            "status": "pending",
            "dependencies": [],
            "details": "GitHub Actions에서 골든 산출물과 현재 산출물을 비교하는 잡을 추가합니다. 오디오/피치/스펙트럼 메트릭을 계산하고 허용 오차 이내인지 판정, 골든 갱신 절차 문서화.",
            "testStrategy": "PR: 변경 시 자동 실행, 차이 리포트 업로드, 의도된 변경 시 골든 업데이트 플로우 검증"
          },
          {
            "id": 3,
            "title": "옵션 포스트필터 모듈 설계",
            "description": "포먼트 시프팅/UV 비율 조정 모듈 인터페이스와 안전 기본값 설계(기본 바이패스)",
            "status": "pending",
            "dependencies": [],
            "details": "IPostFilter 인터페이스와 파라미터(formantShift[semitones], uvBalance[0..1], mix[0..1])를 정의합니다. 기본값은 바이패스이며, 체인 가능한 구조와 실시간 안전 변경을 지원합니다.",
            "testStrategy": "단위: 항등/경계 파라미터에서 안정 동작 확인\n품질: 합성 샘플에 적용 시 스펙트럼 변화와 청감 평가 일치 검증\n성능: 프레임 처리 시간 상한 검증"
          }
        ]
      },
      {
        "id": 20,
        "title": "vv_world CLI 문서와 예제 구축",
        "description": "`vv_world` CLI와 코어 라이브러리에 대한 간결한 문서와 실용 예제를 작성합니다. 입력/출력 사양, 자주 쓰는 사용 패턴, 트러블슈팅을 포함합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4,
          7,
          11,
          14,
          15,
          19
        ],
        "priority": "high",
        "details": "This task involves developing comprehensive user-facing documentation and runnable examples for the `vv_world` command-line interface and its underlying core library. The documentation should be structured for clarity and ease of use, targeting both end-users and developers.\n\n1.  **`vv_world` CLI Reference**:\n    *   **Installation & Setup**: Provide brief instructions on how to obtain and run `vv_world` (assuming pre-built binaries or a simple build process).\n    *   **General Usage**: Explain the basic command structure and common global options (e.g., `--help`, `--version`).\n    *   **Core Commands Documentation**: Detail each primary CLI command, including its purpose, all available arguments, accepted values, and default behaviors. This includes:\n        *   `analyze`: Document input (WAV) and output (`f0.txt`, `sp.bin`, `ap.bin`, `meta.json`) specifications. Explain parameters like frame period and F0 estimation algorithms (Harvest/DIO).\n        *   `synthesize`: Document input (`f0.txt`, `sp.bin`, `ap.bin`, `meta.json`) and output (WAV) specifications. Explain parameters like synthesis engine selection (WORLD, PSOLA, ONNX) and output audio properties (sample rate, bit depth).\n        *   `resample` (UTAU compatibility mode): Document the `resampler.exe`/`wavtool.exe` compatible arguments, how UTAU flags (e.g., gender, modulation, velocity) are interpreted and mapped to internal parameters.\n        *   `server`: Explain how to start and interact with the persistent resampler server, including available IPC options (HTTP/gRPC/UDS) and client usage examples.\n        *   `filter`: Describe how to apply post-synthesis filters (e.g., formant shift, unvoiced/voiced adjustments), including their parameters and effects.\n    *   **Input/Output Specifications**: Provide detailed descriptions of all supported file formats (`.wav`, `.txt`, `.bin`, `.json`), including data types, endianness, and structural layouts.\n\n2.  **Core Library API Usage (e.g., C++/Python)**:\n    *   **Initialization**: Demonstrate how to initialize the `vv_world` core library.\n    *   **`DataPacket` Handling**: Provide examples of creating, populating, and accessing `DataPacket` objects.\n    *   **Node Execution**: Illustrate how to instantiate and run core processing nodes like `WorldAnalysisNode`, `WorldSynthesisNode`, `UnitSelectionNode`, `OnnxInferenceNode`, and `LlsmModelNode` directly.\n    *   **Parameter Passing**: Show how to pass configuration parameters to individual nodes.\n    *   **Error Handling**: Document best practices for handling errors returned by the library.\n\n3.  **Common Recipes & Workflows**: Provide step-by-step guides for typical use cases, such as:\n    *   \"Full analysis-synthesis pipeline from WAV to WAV.\"\n    *   \"Generating UTAU-compatible voicebank artifacts from a raw WAV.\"\n    *   \"Synthesizing from UTAU `.ust` files using `vv_world` as a resampler.\"\n    *   \"Using the persistent server for low-latency synthesis.\"\n    *   \"Applying post-synthesis effects to an existing WAV.\"\n    *   \"Batch processing multiple audio files.\"\n\n4.  **Troubleshooting Guide**: Compile a list of common issues, their typical error messages, and actionable solutions (e.g., missing dependencies, invalid input formats, performance bottlenecks, distorted audio).",
        "testStrategy": "1.  **Automated Example Validation**: Implement automated scripts (e.g., shell scripts for CLI, Python scripts for core library) to execute all commands and code examples provided in the documentation. Verify that they run without errors and produce the expected output files or data. Compare output audio/data against known good references where applicable.\n2.  **Documentation Review**: Conduct thorough internal reviews by developers and, if possible, external user acceptance testing (UAT) by target users to ensure clarity, accuracy, completeness, and ease of understanding. Collect feedback on terminology, formatting, and overall usability.\n3.  **Input/Output Specification Verification**: Systematically validate that the documented input and output specifications precisely match the actual behavior and requirements of the `vv_world` implementation.\n4.  **Troubleshooting Scenario Testing**: For each entry in the troubleshooting guide, simulate the described problem and verify that the provided solution effectively resolves the issue.\n5.  **Coverage Review**: Ensure that all major CLI commands, core library functionalities, and common use cases are adequately covered in the documentation, leaving no significant gaps.",
        "subtasks": [
          {
            "id": 1,
            "title": "vv_world 기본 사용 가이드 작성",
            "description": "입력/출력 인자, 파이프라인 개요, 필수/선택 플래그 설명 포함",
            "status": "pending",
            "dependencies": [],
            "details": "docs/cli/README.md에 설치, --help 출력, 기본 서브커맨드(analyze/synthesize/resample/server/filter) 개요, 예시 인자를 정리합니다. 오류 코드/종료 코드 테이블과 자주 묻는 질문을 포함합니다.",
            "testStrategy": "스크립트로 --help 및 기본 예시 실행 스모크 테스트, 문서 내 커맨드가 모두 성공하는지 점검"
          },
          {
            "id": 2,
            "title": "예제 레시피 추가",
            "description": "WORLD 분석/합성 예제, PSOLA 예제, ONNX 추론 예제 각각 최소 1개",
            "status": "pending",
            "dependencies": [],
            "details": "examples/vv_world/에 스크립트와 샘플 데이터를 배치합니다.\n- WAV→분석→합성\n- UTAU 호환 리샘플링\n- ONNX 추론 경로\n모든 예제는 산출물 경로와 기대 파일 목록을 문서화합니다.",
            "testStrategy": "예제 실행 후 산출물 존재/포맷 확인, 필요 시 간단한 품질/시간 메트릭 수집"
          },
          {
            "id": 3,
            "title": "I/O 사양 및 에러 코드 표 정리",
            "description": "입출력 파일 포맷, 샘플레이트/채널 정책, 리턴코드/에러 메시지 표",
            "status": "pending",
            "dependencies": [],
            "details": "지원 포맷(WAV/f0.txt/sp.bin/ap.bin/meta.json)의 필드/엔디안/정밀도를 표로 정리하고, CLI 리턴코드와 에러 메시지 매핑표를 문서화합니다. JSON Schema(메타) 제공.",
            "testStrategy": "문서-코드 싱크 검사: 스키마로 메타 파일 검증, 에러 코드 표와 실제 코드 상수 교차검증"
          }
        ]
      },
      {
        "id": 21,
        "title": "WORLD 파이프라인 성능 옵션 노출",
        "description": "멀티스레딩, 블록 처리, 윈도우 종류, STFT 파라미터를 사용자 조절 옵션으로 노출하고 안전하고 합리적인 기본값을 제공합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4,
          20
        ],
        "priority": "medium",
        "details": "This task involves enhancing the WORLD analysis and synthesis pipeline by exposing key performance and quality parameters as user-tunable options. The goal is to provide users with greater control over the trade-offs between processing speed, resource usage, and audio quality.\n\n1.  **Parameter Identification and Integration:**\n    *   **Multithreading:** Implement an option to control the number of threads used for parallel processing within the `WorldAnalysisNode` and `WorldSynthesisNode`. This could involve a thread pool or parallel loops for frame-level operations.\n    *   **Block Processing (Frame Parameters):** Expose `frame_period` (hop size) and `fft_size` as configurable options. These directly impact the granularity of analysis/synthesis and computational load.\n    *   **Window Types:** Allow users to select different window functions for STFT, such as Hanning, Hamming, Blackman, or Rectangular. This will require modifying the STFT utility functions used by WORLD.\n    *   **STFT/Analysis Parameters:** Expose other relevant WORLD parameters like `f0_floor`, `f0_ceil`, and `alpha` (for CheapTrick spectral envelope estimation).\n\n2.  **Exposure Mechanism:**\n    *   Integrate these new parameters into the `vv_world` command-line interface (CLI) as optional arguments.\n    *   Ensure that `WorldAnalysisNode` and `WorldSynthesisNode` (Task 3) can accept and utilize these parameters, potentially via their initialization or `process()` methods, or by extending the `DataPacket` (Task 2) to carry configuration.\n    *   Define robust and safe default values for all new options to ensure good out-of-the-box performance and quality.\n\n3.  **Documentation:**\n    *   Update the `vv_world` CLI usage guide and examples (Task 20) to thoroughly document each new option, including its purpose, valid range, default value, and potential impact on performance and audio quality.\n    *   Provide practical examples demonstrating how to use these options to achieve different performance/quality profiles.",
        "testStrategy": "1.  **Unit Tests:** Develop unit tests for parameter parsing and validation within the CLI and for ensuring that the `WorldAnalysisNode` and `WorldSynthesisNode` correctly apply the received parameters.\n2.  **Functional Tests:** Run `vv_world` with various combinations of the newly exposed parameters (e.g., different thread counts, frame periods, window types, F0 ranges) to verify correct execution and output.\n3.  **Performance Benchmarking:** Conduct systematic performance tests (CPU usage, memory footprint, execution time) using the benchmarking suite (Task 18) across a range of parameter settings, especially for multithreading and block processing, to quantify their impact.\n4.  **Audio Quality Assessment:** Perform objective (e.g., PESQ, STOI) and subjective listening tests on synthesized audio generated with different parameter combinations to ensure that quality remains acceptable or improves as expected.\n5.  **Documentation Verification:** Review the updated CLI usage guide and examples (Task 20) to confirm accuracy, clarity, and completeness of the new options' documentation.",
        "subtasks": [
          {
            "id": 1,
            "title": "멀티스레딩/블록처리 옵션 노출",
            "description": "스레드 수, 프레임 블록 크기, 워크스틸링 기본값 정의 및 CLI 플래그화",
            "status": "pending",
            "dependencies": [],
            "details": "CLI 플래그: --threads, --block-frames, --work-stealing.\n- 기본값: 하드웨어 스레드 수 감지, 블록 크기 자동 추정\n- 범위: 하드코어 상한/하한 및 유효성 검사\n- 전파: WorldAnalysis/Synthesis 노드에 안전하게 전달",
            "testStrategy": "기능: 다양한 조합으로 실행 성공 및 크래시/데드락 없음 확인\n성능: 벤치 스위트로 시간 단축/스케일링 특성 측정"
          },
          {
            "id": 2,
            "title": "윈도우/STFT 파라미터 노출",
            "description": "윈도우 종류, FFT 크기, 홉사이즈, 프리엠퍼시스 옵션 노출 및 문서화",
            "status": "pending",
            "dependencies": [],
            "details": "CLI 플래그: --window(hann/hamming/blackman/rect), --fft-size, --hop, --preemphasis.\n- 검증: 파워오브투, 범위 체크, 상호 제약 확인\n- 품질: 파라미터가 합성 품질/속도에 미치는 영향 문서화",
            "testStrategy": "단위: 파라미터 파싱/검증 테스트\n품질: 주요 조합에서 객관/주관 품질 측정(PESQ/STOI)"
          },
          {
            "id": 3,
            "title": "안전 기본값 및 호환성 가이드",
            "description": "OpenUtau/UTAU 호환에 안전한 기본값과 권장 조합 표 작성",
            "status": "pending",
            "dependencies": [],
            "details": "docs/compat_recipes.md에 호스트별(OU/CLI) 안전 기본값과 권장 조합을 표로 정리하고, 문제 발생 시 대체 설정을 제시합니다.",
            "testStrategy": "샘플 프로젝트로 가이드 조합을 실행해 성공/품질 기준 충족 여부 확인"
          }
        ]
      },
      {
        "id": 22,
        "title": "고급 합성 모드: 포먼트 보존 & 글로털 파라미터 프로토타이핑",
        "description": "GPL 오염 없이 포먼트 보존 개선과 고급 글로털 파라미터 실험에 초점을 둔 선택적 합성 모듈을 프로토타입하고 평가합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "low",
        "details": "This R&D task involves exploring and implementing advanced signal processing techniques to enhance the quality and control of synthesized speech, specifically targeting formant preservation and glottal source modeling.\n\n1.  **Research and Algorithm Selection:**\n    *   Identify state-of-the-art algorithms for robust formant tracking and preservation during pitch/duration modification (e.g., alternative spectral envelope estimation methods, adaptive filtering techniques).\n    *   Investigate advanced glottal source models beyond simple aperiodicity, such as glottal inverse filtering, Liljencrants-Fant (LF) model, or other parametric glottal flow models, to enable finer control over voice quality (e.g., breathiness, vocal fry).\n    *   Prioritize algorithms that can be implemented from scratch or are available under permissively licensed (e.g., MIT, Apache 2.0, BSD) terms to strictly avoid GPL contamination.\n\n2.  **Module Design and Implementation:**\n    *   Design new `ISynthesisNode` or `IAnalysisNode` derived classes, or extend existing `WorldAnalysisNode`/`WorldSynthesisNode` functionalities, to encapsulate these experimental algorithms.\n    *   Ensure the new modules are optional and can be easily integrated into the existing `ComputationGraph` (Task 2) for A/B testing against current methods.\n    *   For formant preservation, implement techniques that explicitly model and preserve formant frequencies and bandwidths throughout the synthesis process, potentially as an alternative or enhancement to `CheapTrick` within WORLD.\n    *   For glottal parameters, develop methods to extract more detailed glottal source characteristics from input audio and allow for their manipulation during synthesis, providing new control parameters to users.\n\n3.  **Integration and Parameterization:**\n    *   Integrate the prototyped modules into the synthesis pipeline, ensuring compatibility with existing `DataPacket` structures (Task 2).\n    *   Define clear, configurable parameters for each new module, allowing for experimental tuning and future exposure to users.\n\n4.  **Documentation:**\n    *   Document the theoretical basis, implementation choices, and parameterization of each prototyped module.",
        "testStrategy": "A multi-faceted testing approach will be employed to validate the functionality, quality, and performance of the new synthesis modules.\n\n1.  **Unit Tests:**\n    *   Develop comprehensive unit tests for each new algorithm or sub-component within the prototyped modules. These tests should verify mathematical correctness, handle edge cases, and ensure expected outputs for controlled inputs (e.g., synthetic signals).\n    *   Test the extraction and manipulation of specific formant and glottal parameters independently.\n\n2.  **Integration Tests:**\n    *   Verify that the new `ISynthesisNode` or `IAnalysisNode` implementations integrate seamlessly into the `ComputationGraph` and correctly process `DataPacket`s.\n    *   Test the optional enabling/disabling mechanism for the new modules, ensuring that the pipeline functions correctly with and without them.\n\n3.  **Objective Quality Evaluation:**\n    *   Prepare a diverse dataset of test audio samples covering various speakers, pitches, and voice qualities.\n    *   Synthesize these samples using both the baseline (current WORLD pipeline) and the new experimental modules.\n    *   Employ objective metrics to compare the synthesized outputs:\n        *   **Formant Accuracy:** Use specialized tools to track formant frequencies and bandwidths in both original and synthesized audio, quantifying preservation.\n        *   **Glottal Source Analysis:** Analyze glottal flow derivatives (e.g., using open-source tools like Praat or custom scripts) to compare glottal parameters (e.g., open quotient, speed quotient) between original and synthesized speech.\n        *   **General Quality:** Utilize metrics like Mel-Cepstral Distortion (MCD), PESQ (Perceptual Evaluation of Speech Quality), and STOI (Short-Time Objective Intelligibility) to assess overall speech quality and intelligibility.\n\n4.  **Subjective Listening Tests:**\n    *   Conduct blind listening tests with human evaluators to assess the perceived naturalness, intelligibility, and the specific impact of formant preservation and glottal parameter manipulation on voice quality.\n    *   Gather feedback on the perceived improvements or degradations compared to the baseline.\n\n5.  **Performance Benchmarking:**\n    *   Measure the computational overhead (CPU usage, memory consumption, processing time) introduced by the new modules.\n    *   Compare the performance against the existing synthesis pipeline to ensure that quality improvements do not lead to unacceptable performance regressions.\n\n6.  **License Compliance Audit:**\n    *   Rigorously review all new code and any integrated third-party components to confirm strict adherence to the non-GPL licensing requirement, ensuring no contamination.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-09T11:30:33.895Z",
      "updated": "2025-08-10T08:16:40.236Z",
      "description": "Tasks for master context"
    }
  }
}